//! Integration tests for xcert-lib using generated test certificates.
//!
//! Test certificates are in tests/certs/ (generated by tests/certs/generate.sh).
//! Reference outputs from openssl x509 are in tests/certs/reference/.
//!
//! These tests exercise the library API against known-good certificates and
//! compare results to openssl x509 output where applicable.

// Security-audit lints are useful for production code but not for test assertions
// where expect/unwrap/panic/indexing are standard practice.
#![allow(
    clippy::expect_used,
    clippy::unwrap_used,
    clippy::panic,
    clippy::indexing_slicing
)]

use xcert_lib::*;

// ---------------------------------------------------------------------------
// Helper: load a test certificate file
// ---------------------------------------------------------------------------

fn cert_path(name: &str) -> std::path::PathBuf {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop(); // up from xcert-lib to workspace root
    p.push("tests");
    p.push("certs");
    p.push(name);
    p
}

fn reference_path(name: &str) -> std::path::PathBuf {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop(); // up from xcert-lib to workspace root
    p.push("tests");
    p.push("certs");
    p.push("reference");
    p.push(name);
    p
}

fn load_reference(name: &str) -> String {
    std::fs::read_to_string(reference_path(name))
        .unwrap_or_else(|e| panic!("Failed to read reference '{}': {}", name, e))
        .trim()
        .to_string()
}

fn load_cert(name: &str) -> Vec<u8> {
    std::fs::read(cert_path(name)).unwrap_or_else(|e| {
        panic!(
            "Failed to read test certificate '{}': {}. Run tests/certs/generate.sh first.",
            name, e
        )
    })
}

// =========================================================================
// 1. PARSING TESTS
// =========================================================================

mod parsing {
    use super::*;

    #[test]
    fn parse_rsa_pem() {
        let data = load_cert("root-ca.pem");
        let cert = parse_pem(&data).expect("should parse root CA PEM");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_rsa_der() {
        let data = load_cert("root-ca.der");
        let cert = parse_der(&data).expect("should parse root CA DER");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_pem() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).expect("should auto-detect PEM and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_der() {
        let data = load_cert("server.der");
        let cert = parse_cert(&data).expect("should auto-detect DER and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_ec_p256() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).expect("should parse ECDSA P-256 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "EC");
    }

    #[test]
    fn parse_ec_p384() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).expect("should parse ECDSA P-384 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "EC");
    }

    #[test]
    fn parse_ed25519() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).expect("should parse Ed25519 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "Ed25519");
    }

    #[test]
    fn parse_minimal_self_signed() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).expect("should parse minimal cert");
        // Minimal cert created with -subj "/CN=Minimal Test"
        assert!(cert.subject_string().contains("Minimal Test"));
    }

    #[test]
    fn parse_expired_cert() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).expect("should parse expired cert");
        assert!(cert.subject_string().contains("Expired Test"));
    }

    #[test]
    fn parse_many_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).expect("should parse cert with many extensions");
        assert!(!cert.extensions.is_empty(), "should have extensions");
    }

    #[test]
    fn parse_utf8_subject() {
        let data = load_cert("utf8-subject.pem");
        let cert = parse_cert(&data).expect("should parse cert with UTF-8 subject");
        // Should contain French characters
        let subject = cert.subject_string();
        assert!(
            subject.contains("Paris") || subject.contains("France"),
            "UTF-8 subject should contain French location, got: {}",
            subject
        );
    }

    #[test]
    fn parse_chain_takes_first_cert() {
        let data = load_cert("chain.pem");
        let cert = parse_cert(&data).expect("should parse first cert in chain");
        // chain.pem = server + intermediate + root; first should be server
        assert!(cert.subject_string().contains("www.example.com"));
    }

    #[test]
    fn parse_invalid_data_returns_error() {
        let data = b"this is not a certificate";
        assert!(parse_cert(data).is_err());
    }

    #[test]
    fn parse_empty_input_returns_error() {
        assert!(parse_cert(b"").is_err());
    }

    #[test]
    fn parse_truncated_der_returns_error() {
        let data = load_cert("root-ca.der");
        let truncated = &data[..data.len() / 2];
        assert!(parse_der(truncated).is_err());
    }
}

// =========================================================================
// 2. FIELD EXTRACTION TESTS
// =========================================================================

mod fields {
    use super::*;

    // --- Subject ---

    #[test]
    fn root_ca_subject() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(subject.contains("Test Root CA"), "subject: {}", subject);
        assert!(subject.contains("US"), "subject should contain country");
        assert!(subject.contains("Test PKI"), "subject should contain org");
    }

    #[test]
    fn server_subject() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(subject.contains("www.example.com"), "subject: {}", subject);
        assert!(
            subject.contains("Example Corp"),
            "subject should contain org"
        );
    }

    #[test]
    fn ec_p256_subject() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("ec-test.example.com"),
            "subject: {}",
            subject
        );
        assert!(subject.contains("DE"), "subject should contain country DE");
    }

    #[test]
    fn ed25519_subject() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("ed25519.example.com"),
            "subject: {}",
            subject
        );
    }

    // --- Issuer ---

    #[test]
    fn root_ca_is_self_signed() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(
            cert.subject_string(),
            cert.issuer_string(),
            "root CA should be self-signed"
        );
    }

    #[test]
    fn server_issuer_is_intermediate() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let issuer = cert.issuer_string();
        assert!(
            issuer.contains("Test Intermediate CA"),
            "issuer: {}",
            issuer
        );
    }

    #[test]
    fn intermediate_issuer_is_root() {
        let data = load_cert("intermediate-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let issuer = cert.issuer_string();
        assert!(issuer.contains("Test Root CA"), "issuer: {}", issuer);
    }

    // --- Serial ---

    #[test]
    fn root_ca_serial() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let serial = cert.serial_hex();
        // openssl reports serial=01
        assert!(
            serial == "01" || serial == "1",
            "root CA serial should be 01, got: {}",
            serial
        );
    }

    #[test]
    fn server_serial() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let serial = cert.serial_hex();
        // openssl reports serial=1000
        // Serial 0x1000 can be "10:00" (colon-separated) or "1000"
        let serial_stripped = serial.replace(":", "");
        assert!(
            serial_stripped.to_uppercase().contains("1000"),
            "server serial should contain 1000, got: {}",
            serial
        );
    }

    // --- Dates ---

    #[test]
    fn server_dates_are_reasonable() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // not_before should be in 2026
        assert!(
            cert.not_before_string().contains("2026"),
            "not_before: {}",
            cert.not_before_string()
        );
        // not_after should be in 2101 (75 year validity)
        assert!(
            cert.not_after_string().contains("2101"),
            "not_after: {}",
            cert.not_after_string()
        );
    }

    #[test]
    fn expired_cert_dates() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // The expired cert has 1-day validity
        let not_before = cert.not_before_string();
        let not_after = cert.not_after_string();
        assert!(!not_before.is_empty(), "not_before should not be empty");
        assert!(!not_after.is_empty(), "not_after should not be empty");
    }

    // --- Public Key Info ---

    #[test]
    fn server_rsa_2048_key() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
    }

    #[test]
    fn ec_p256_key_info() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(
            cert.public_key.curve.as_deref(),
            Some("P-256"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ec_p384_key_info() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(
            cert.public_key.curve.as_deref(),
            Some("P-384"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ed25519_key_info() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "Ed25519");
    }

    #[test]
    fn rsa_modulus_present() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let modulus = cert.modulus_hex();
        assert!(modulus.is_some(), "RSA cert should have modulus");
        let modulus = modulus.unwrap();
        assert!(!modulus.is_empty(), "modulus should not be empty");
    }

    #[test]
    fn ec_has_no_modulus() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.modulus_hex().is_none(),
            "EC cert should not have modulus"
        );
    }

    #[test]
    fn public_key_pem_format() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let pem = cert.public_key_pem();
        assert!(
            pem.contains("BEGIN PUBLIC KEY"),
            "public key PEM should have header"
        );
        assert!(
            pem.contains("END PUBLIC KEY"),
            "public key PEM should have footer"
        );
    }

    // --- Signature Algorithm ---

    #[test]
    fn server_sha256_rsa_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha256")
                || cert.signature_algorithm.contains("SHA256")
                || cert.signature_algorithm.contains("sha256WithRSAEncryption"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }

    #[test]
    fn ec_p384_sha384_signature() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha384")
                || cert.signature_algorithm.contains("SHA384")
                || cert.signature_algorithm.contains("ecdsa-with-SHA384"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }
}

// =========================================================================
// 3. EXTENSION TESTS
// =========================================================================

mod extensions {
    use super::*;

    #[test]
    fn root_ca_is_ca() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "root CA should have BasicConstraints");
        if let Some(ext) = bc {
            assert!(ext.critical, "BasicConstraints should be critical on CA");
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(ca, "CA flag should be true");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn intermediate_ca_pathlen_zero() {
        let data = load_cert("intermediate-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "intermediate CA should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, path_len } => {
                    assert!(ca, "CA flag should be true");
                    assert_eq!(*path_len, Some(0), "pathlen should be 0");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_not_ca() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "server should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(!ca, "server CA flag should be false");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "server should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter()
                .any(|u| u.contains("Digital Signature") || u.contains("digitalSignature")),
            "should include Digital Signature, got: {:?}",
            ku
        );
        assert!(
            ku.iter()
                .any(|u| u.contains("Key Encipherment") || u.contains("keyEncipherment")),
            "should include Key Encipherment, got: {:?}",
            ku
        );
    }

    #[test]
    fn server_extended_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "server should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter()
                .any(|u| u.contains("Server") || u.contains("serverAuth")),
            "should include serverAuth, got: {:?}",
            eku
        );
    }

    #[test]
    fn client_extended_key_usage() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "client should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter()
                .any(|u| u.contains("Client") || u.contains("clientAuth")),
            "should include clientAuth, got: {:?}",
            eku
        );
        assert!(
            eku.iter()
                .any(|u| u.contains("mail") || u.contains("emailProtection")),
            "should include emailProtection, got: {:?}",
            eku
        );
    }

    #[test]
    fn server_san_dns_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        assert!(!san.is_empty(), "server should have SAN entries");

        let dns_names: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Dns(name) => Some(name.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            dns_names.contains(&"www.example.com"),
            "should contain www.example.com, got: {:?}",
            dns_names
        );
        assert!(
            dns_names.contains(&"example.com"),
            "should contain example.com"
        );
        assert!(
            dns_names.contains(&"*.example.com"),
            "should contain *.example.com"
        );
    }

    #[test]
    fn server_san_ip_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let ips: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Ip(ip) => Some(ip.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            ips.iter().any(|ip| ip.contains("93.184.216.34")),
            "should contain IPv4 93.184.216.34, got: {:?}",
            ips
        );
        // IPv6 address
        assert!(
            ips.iter().any(|ip| ip.to_lowercase().contains("2606:2800")),
            "should contain IPv6 address, got: {:?}",
            ips
        );
    }

    #[test]
    fn server_san_email_entry() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let emails: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Email(email) => Some(email.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            emails.contains(&"admin@example.com"),
            "should contain admin@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn server_authority_info_access() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let ocsp_urls = cert.ocsp_urls();
        assert!(
            ocsp_urls.iter().any(|u| u.contains("ocsp.example.com")),
            "should have OCSP URL, got: {:?}",
            ocsp_urls
        );
    }

    #[test]
    fn many_extensions_cert_has_expected_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();

        let ext_names: Vec<&str> = cert.extensions.iter().map(|e| e.name.as_str()).collect();

        // Should have at least: BasicConstraints, KeyUsage, ExtendedKeyUsage, SKI, AKI, SAN, AIA, CRL DP
        assert!(
            ext_names.iter().any(|n| n.contains("Basic")),
            "should have BasicConstraints"
        );
        assert!(
            ext_names
                .iter()
                .any(|n| n.contains("Key Usage") && !n.contains("Extended")),
            "should have KeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Extended")),
            "should have ExtendedKeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Subject Alternative")),
            "should have SubjectAltName"
        );
        assert!(
            ext_names
                .iter()
                .any(|n| n.contains("Authority Information")),
            "should have AuthorityInfoAccess"
        );
    }

    #[test]
    fn many_extensions_eku_values() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some());
        let eku = eku.unwrap();
        // Should include: serverAuth, clientAuth, codeSigning, emailProtection, timeStamping
        assert!(
            eku.len() >= 5,
            "should have at least 5 EKU values, got {} : {:?}",
            eku.len(),
            eku
        );
    }

    #[test]
    fn many_extensions_san_has_uri() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let uris: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Uri(u) => Some(u.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            uris.iter().any(|u| u.contains("example.com/cert-info")),
            "should contain URI SAN, got: {:?}",
            uris
        );
    }

    #[test]
    fn root_ca_key_usage_includes_cert_sign() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "root CA should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter().any(|u| u.contains("Cert Sign")
                || u.contains("keyCertSign")
                || u.contains("Certificate Sign")),
            "root CA should have keyCertSign, got: {:?}",
            ku
        );
    }

    #[test]
    fn minimal_cert_has_no_san() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        // A minimal self-signed cert may or may not have SAN depending on openssl defaults
        // But our explicitly minimal cert should have minimal extensions
        // This is a structural test -- we mainly verify it doesn't crash
        let _ = san;
    }
}

// =========================================================================
// 4. FINGERPRINT TESTS
// =========================================================================

mod fingerprints {
    use super::*;

    /// Parse OpenSSL fingerprint like "sha256 Fingerprint=AA:BB:CC:..."
    fn expected_fingerprint(ref_file: &str) -> String {
        let line = load_reference(ref_file);
        line.split('=')
            .nth(1)
            .unwrap_or(&line)
            .trim()
            .to_uppercase()
    }

    #[test]
    fn root_ca_sha256_fingerprint() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        let expected = expected_fingerprint("root-ca-fingerprint-sha256.txt");
        assert_eq!(fp.to_uppercase(), expected, "SHA-256 fingerprint mismatch");
    }

    #[test]
    fn root_ca_sha1_fingerprint() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha1);
        let expected = expected_fingerprint("root-ca-fingerprint-sha1.txt");
        assert_eq!(fp.to_uppercase(), expected, "SHA-1 fingerprint mismatch");
    }

    #[test]
    fn server_sha256_fingerprint() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        let expected = expected_fingerprint("server-fingerprint-sha256.txt");
        assert_eq!(fp.to_uppercase(), expected, "SHA-256 fingerprint mismatch");
    }

    #[test]
    fn many_extensions_sha256_fingerprint() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        let expected = expected_fingerprint("many-extensions-fingerprint-sha256.txt");
        assert_eq!(fp.to_uppercase(), expected, "SHA-256 fingerprint mismatch");
    }

    #[test]
    fn fingerprint_from_pem_matches_der() {
        let pem_data = load_cert("root-ca.pem");
        let der_data = load_cert("root-ca.der");
        let pem_cert = parse_pem(&pem_data).unwrap();
        let der_cert = parse_der(&der_data).unwrap();
        assert_eq!(
            pem_cert.fingerprint(DigestAlgorithm::Sha256),
            der_cert.fingerprint(DigestAlgorithm::Sha256),
            "PEM and DER should produce the same fingerprint"
        );
    }

    #[test]
    fn sha384_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha384);
        // SHA-384 = 48 bytes = 48*3-1 = 143 chars in colon-separated hex
        assert_eq!(fp.len(), 143, "SHA-384 fingerprint wrong length: {}", fp);
    }

    #[test]
    fn sha512_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha512);
        // SHA-512 = 64 bytes = 64*3-1 = 191 chars in colon-separated hex
        assert_eq!(fp.len(), 191, "SHA-512 fingerprint wrong length: {}", fp);
    }
}

// =========================================================================
// 5. EMAIL EXTRACTION TESTS
// =========================================================================

mod emails {
    use super::*;

    #[test]
    fn server_emails() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(
            emails.contains(&"admin@example.com".to_string()),
            "should contain admin@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn client_emails() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(
            emails.contains(&"client@example.com".to_string()),
            "should contain client@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn root_ca_no_emails() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(emails.is_empty(), "root CA should have no emails");
    }
}

// =========================================================================
// 6. CHECK TESTS
// =========================================================================

mod checks {
    use super::*;

    // --- Expiry ---

    #[test]
    fn server_not_expired() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // Server cert valid until 2101; checking with 0 seconds means "is it valid now?"
        assert!(check_expiry(&cert, 0), "server cert should not be expired");
    }

    #[test]
    fn server_valid_for_one_year() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_expiry(&cert, 365 * 24 * 60 * 60),
            "server cert should be valid for at least 1 year"
        );
    }

    #[test]
    fn expired_cert_is_expired() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // Check if it expires within 10 years (it already has since it was 1-day)
        assert!(
            !check_expiry(&cert, 315_360_000),
            "expired cert should be detected as expiring"
        );
    }

    // --- Hostname ---

    #[test]
    fn hostname_exact_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "www.example.com"),
            "should match www.example.com"
        );
    }

    #[test]
    fn hostname_bare_domain_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "example.com"),
            "should match example.com (in SAN)"
        );
    }

    #[test]
    fn hostname_wildcard_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "sub.example.com"),
            "should match *.example.com wildcard"
        );
    }

    #[test]
    fn hostname_wildcard_does_not_match_deep_subdomain() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "deep.sub.example.com"),
            "wildcard should not match deep.sub.example.com"
        );
    }

    #[test]
    fn hostname_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "bad.example.org"),
            "should not match bad.example.org"
        );
    }

    #[test]
    fn hostname_case_insensitive() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "WWW.EXAMPLE.COM"),
            "hostname matching should be case-insensitive"
        );
    }

    // --- IP ---

    #[test]
    fn ip_v4_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "93.184.216.34"),
            "should match IPv4 93.184.216.34"
        );
    }

    #[test]
    fn ip_v4_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(!check_ip(&cert, "1.2.3.4"), "should not match 1.2.3.4");
    }

    #[test]
    fn ip_v6_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "2606:2800:220:1:248:1893:25c8:1946"),
            "should match IPv6 address"
        );
    }

    // --- Email ---

    #[test]
    fn email_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_email(&cert, "admin@example.com"),
            "should match admin@example.com"
        );
    }

    #[test]
    fn email_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_email(&cert, "nobody@bad.com"),
            "should not match nobody@bad.com"
        );
    }

    #[test]
    fn client_email_match() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_email(&cert, "client@example.com"),
            "should match client@example.com"
        );
    }
}

// =========================================================================
// 7. CONVERSION TESTS
// =========================================================================

mod conversion {
    use super::*;

    #[test]
    fn pem_to_der_conversion() {
        let pem_data = load_cert("root-ca.pem");
        let expected_der = load_cert("root-ca.der");
        let result = pem_to_der(&pem_data).expect("PEM to DER should succeed");
        assert_eq!(result, expected_der, "converted DER should match reference");
    }

    #[test]
    fn der_to_pem_conversion() {
        let der_data = load_cert("root-ca.der");
        let pem_str = der_to_pem(&der_data);
        assert!(
            pem_str.contains("BEGIN CERTIFICATE"),
            "should have PEM header"
        );
        assert!(
            pem_str.contains("END CERTIFICATE"),
            "should have PEM footer"
        );
    }

    #[test]
    fn pem_to_der_to_pem_roundtrip() {
        let original_pem = load_cert("server.pem");
        let der = pem_to_der(&original_pem).expect("PEM to DER should succeed");
        let pem_again = der_to_pem(&der);

        // The PEM might have different whitespace, so compare via DER
        let der_again = pem_to_der(pem_again.as_bytes()).expect("should parse regenerated PEM");
        assert_eq!(der, der_again, "roundtrip should preserve certificate");
    }

    #[test]
    fn der_to_pem_to_der_roundtrip() {
        let original_der = load_cert("server.der");
        let pem = der_to_pem(&original_der);
        let der_again = pem_to_der(pem.as_bytes()).expect("should parse generated PEM");
        assert_eq!(
            original_der, der_again,
            "roundtrip should preserve certificate"
        );
    }

    #[test]
    fn pem_to_der_invalid_input() {
        assert!(pem_to_der(b"not a pem").is_err());
    }
}

// =========================================================================
// 8. DISPLAY TESTS
// =========================================================================

mod display {
    use super::*;

    #[test]
    fn display_text_contains_subject() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("www.example.com"),
            "text output should contain subject CN"
        );
    }

    #[test]
    fn display_text_contains_issuer() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Test Intermediate CA"),
            "text output should contain issuer CN"
        );
    }

    #[test]
    fn display_text_contains_serial() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("1000") || text.contains("10:00"),
            "text output should contain serial number"
        );
    }

    #[test]
    fn display_text_contains_validity() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("2026") && text.contains("2101"),
            "text output should contain validity dates"
        );
    }

    #[test]
    fn display_text_contains_extensions() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Subject Alternative Name")
                || text.contains("SAN")
                || text.contains("subjectAltName"),
            "text output should mention SAN extension"
        );
    }

    #[test]
    fn display_text_contains_fingerprint() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Fingerprint") || text.contains("fingerprint"),
            "text output should contain fingerprint"
        );
    }

    #[test]
    fn display_text_all_includes_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, true);
        assert!(
            text.contains("Signature") || text.contains("signature"),
            "display_text with show_all should include signature"
        );
    }

    #[test]
    fn json_output_is_valid() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let json_str = to_json(&cert).expect("JSON serialization should succeed");
        let parsed: serde_json::Value =
            serde_json::from_str(&json_str).expect("output should be valid JSON");
        assert!(parsed.is_object(), "JSON root should be an object");
    }

    #[test]
    fn json_contains_expected_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let json_str = to_json(&cert).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();

        assert!(parsed.get("version").is_some(), "JSON should have version");
        assert!(parsed.get("serial").is_some(), "JSON should have serial");
        assert!(parsed.get("subject").is_some(), "JSON should have subject");
        assert!(parsed.get("issuer").is_some(), "JSON should have issuer");
        assert!(
            parsed.get("not_before").is_some(),
            "JSON should have not_before"
        );
        assert!(
            parsed.get("not_after").is_some(),
            "JSON should have not_after"
        );
        assert!(
            parsed.get("extensions").is_some(),
            "JSON should have extensions"
        );
    }
}

// =========================================================================
// 9. ALGORITHM-SPECIFIC TESTS
// =========================================================================

mod algorithms {
    use super::*;

    #[test]
    fn rsa_cert_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert!(cert.public_key.modulus.is_some());
        assert!(cert.public_key.curve.is_none());
    }

    #[test]
    fn ecdsa_p256_cert_fields() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-256")
                || cert.public_key.curve.as_deref() == Some("prime256v1"),
            "curve: {:?}",
            cert.public_key.curve
        );
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn ecdsa_p384_cert_fields() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-384")
                || cert.public_key.curve.as_deref() == Some("secp384r1"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ed25519_cert_fields() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn all_cert_types_produce_valid_fingerprints() {
        for name in &[
            "root-ca.pem",
            "server.pem",
            "client.pem",
            "ec-p256.pem",
            "ec-p384.pem",
            "ed25519.pem",
            "minimal.pem",
            "many-extensions.pem",
        ] {
            let data = load_cert(name);
            let cert = parse_cert(&data).unwrap();
            let fp = cert.fingerprint(DigestAlgorithm::Sha256);
            // SHA-256 = 32 bytes = 32*3-1 = 95 chars
            assert_eq!(
                fp.len(),
                95,
                "SHA-256 fingerprint for {} has wrong length: {} ({})",
                name,
                fp.len(),
                fp
            );
        }
    }
}

// =========================================================================
// 10. DEGENERATE / MALFORMED INPUT TESTS
// =========================================================================
//
// These test vectors exercise edge cases and error-handling paths in the
// parser.  Each test asserts that the library returns an error (or, where
// noted, succeeds gracefully) without panicking or hanging.

mod degenerate {
    use super::*;

    /// Helper: build a path under tests/certs/degenerate/
    fn degen_path(name: &str) -> std::path::PathBuf {
        let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        p.pop(); // up from xcert-lib to workspace root
        p.push("tests");
        p.push("certs");
        p.push("degenerate");
        p.push(name);
        p
    }

    fn load_degen(name: &str) -> Vec<u8> {
        std::fs::read(degen_path(name))
            .unwrap_or_else(|e| panic!("Failed to read degenerate test file '{}': {}", name, e))
    }

    // -----------------------------------------------------------------
    // 1. empty.der -- 0-byte file
    // -----------------------------------------------------------------
    #[test]
    fn empty_file_returns_error() {
        let data = load_degen("empty.der");
        assert!(data.is_empty());
        let result = parse_cert(&data);
        assert!(result.is_err(), "empty input must return an error");
    }

    #[test]
    fn empty_file_der_returns_error() {
        let data = load_degen("empty.der");
        let result = parse_der(&data);
        assert!(result.is_err(), "empty DER input must return an error");
    }

    // -----------------------------------------------------------------
    // 2. one-byte.der -- single SEQUENCE tag, no length or body
    // -----------------------------------------------------------------
    #[test]
    fn one_byte_returns_error() {
        let data = load_degen("one-byte.der");
        assert_eq!(data.len(), 1);
        assert_eq!(data[0], 0x30, "should be a SEQUENCE tag");
        let result = parse_der(&data);
        assert!(result.is_err(), "single byte must return an error");
    }

    #[test]
    fn one_byte_auto_detect_returns_error() {
        let data = load_degen("one-byte.der");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "single byte via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 3. truncated-header.der -- first 10 bytes of a valid DER cert
    // -----------------------------------------------------------------
    #[test]
    fn truncated_header_returns_error() {
        let data = load_degen("truncated-header.der");
        assert_eq!(data.len(), 10);
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "truncated header (10 bytes) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 4. truncated-body.der -- first half of a valid DER cert
    // -----------------------------------------------------------------
    #[test]
    fn truncated_body_returns_error() {
        let data = load_degen("truncated-body.der");
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "truncated body (half cert) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 5. random-bytes.der -- 1024 random bytes
    // -----------------------------------------------------------------
    #[test]
    fn random_bytes_returns_error() {
        let data = load_degen("random-bytes.der");
        assert_eq!(data.len(), 1024);
        let result = parse_der(&data);
        assert!(result.is_err(), "random bytes must return an error");
    }

    #[test]
    fn random_bytes_auto_detect_returns_error() {
        let data = load_degen("random-bytes.der");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "random bytes via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 6. wrong-pem-label.pem -- valid base64 but "BEGIN RSA PRIVATE KEY"
    // -----------------------------------------------------------------
    #[test]
    fn wrong_pem_label_returns_error() {
        let data = load_degen("wrong-pem-label.pem");
        let result = parse_pem(&data);
        assert!(
            result.is_err(),
            "PEM with RSA PRIVATE KEY label must return an error"
        );
    }

    #[test]
    fn wrong_pem_label_auto_detect_returns_error() {
        let data = load_degen("wrong-pem-label.pem");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "wrong PEM label via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 7. corrupt-base64.pem -- PEM headers with invalid base64 body
    // -----------------------------------------------------------------
    #[test]
    fn corrupt_base64_returns_error() {
        let data = load_degen("corrupt-base64.pem");
        let result = parse_pem(&data);
        assert!(result.is_err(), "corrupt base64 PEM must return an error");
    }

    #[test]
    fn corrupt_base64_auto_detect_returns_error() {
        let data = load_degen("corrupt-base64.pem");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "corrupt base64 via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 8. null-bytes.der -- 1024 null bytes
    // -----------------------------------------------------------------
    #[test]
    fn null_bytes_returns_error() {
        let data = load_degen("null-bytes.der");
        assert_eq!(data.len(), 1024);
        assert!(data.iter().all(|&b| b == 0));
        let result = parse_der(&data);
        assert!(result.is_err(), "1024 null bytes must return an error");
    }

    #[test]
    fn null_bytes_auto_detect_returns_error() {
        let data = load_degen("null-bytes.der");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "null bytes via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 9. huge-length.der -- SEQUENCE claiming 2GB, only 100 bytes of data
    // -----------------------------------------------------------------
    #[test]
    fn huge_length_returns_error() {
        let data = load_degen("huge-length.der");
        assert_eq!(data.len(), 106, "header(6) + filler(100)");
        // Must not hang or allocate 2GB; must return an error promptly
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "DER with huge claimed length must return an error"
        );
    }

    #[test]
    fn huge_length_auto_detect_returns_error() {
        let data = load_degen("huge-length.der");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "huge length via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 10. nested-sequence.der -- 100 levels of nested SEQUENCE
    // -----------------------------------------------------------------
    #[test]
    fn nested_sequence_returns_error() {
        let data = load_degen("nested-sequence.der");
        // This is valid DER structurally (nested SEQUENCEs) but is
        // not a valid certificate.  The parser must return an error
        // without stack-overflowing.
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "deeply nested SEQUENCEs (not a cert) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 11. negative-serial.der -- certificate with tweaked negative serial
    // -----------------------------------------------------------------
    #[test]
    fn negative_serial_parses_or_errors_gracefully() {
        let data = load_degen("negative-serial.der");
        // A real-world parser might accept or reject a negative serial.
        // The important thing is it must not panic.
        let result = parse_der(&data);
        // If it succeeds, the serial should be non-empty.
        // If it fails, the error must be an Err, not a panic.
        match result {
            Ok(cert) => {
                let serial = cert.serial_hex();
                assert!(!serial.is_empty(), "if parsed, serial should be non-empty");
            }
            Err(_) => {
                // Returning an error is also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // 12. trailing-garbage.pem -- valid PEM cert + 1KB garbage appended
    // -----------------------------------------------------------------
    #[test]
    fn trailing_garbage_parses_first_cert() {
        let data = load_degen("trailing-garbage.pem");
        // The PEM parser should extract the first valid certificate
        // and ignore trailing garbage after the END marker.
        let result = parse_pem(&data);
        // Depending on the PEM parser, this may succeed (ignoring
        // trailing bytes) or fail.  Either is acceptable; no panic.
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
                assert!(cert.subject_string().contains("Test Root CA"));
            }
            Err(_) => {
                // Returning an error for trailing garbage is also fine
            }
        }
    }

    #[test]
    fn trailing_garbage_auto_detect() {
        let data = load_degen("trailing-garbage.pem");
        let result = parse_cert(&data);
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
            }
            Err(_) => {
                // Also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // 13. multiple-pem.pem -- cert + private key block + cert
    // -----------------------------------------------------------------
    #[test]
    fn multiple_pem_parses_first_cert() {
        let data = load_degen("multiple-pem.pem");
        // parse_pem should take the first PEM block it finds.
        // If the first block is a CERTIFICATE, it should succeed.
        let result = parse_pem(&data);
        match result {
            Ok(cert) => {
                // First block is root-ca.pem
                assert_eq!(cert.version, 3);
                assert!(
                    cert.subject_string().contains("Test Root CA"),
                    "should parse the first cert (root CA)"
                );
            }
            Err(e) => {
                // If the parser rejects mixed PEM, that is acceptable
                // as long as it does not panic
                let _ = e;
            }
        }
    }

    #[test]
    fn multiple_pem_auto_detect() {
        let data = load_degen("multiple-pem.pem");
        let result = parse_cert(&data);
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
            }
            Err(_) => {
                // Also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken inputs should panic parse_cert
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_input() {
        let files = [
            "empty.der",
            "one-byte.der",
            "truncated-header.der",
            "truncated-body.der",
            "random-bytes.der",
            "wrong-pem-label.pem",
            "corrupt-base64.pem",
            "null-bytes.der",
            "huge-length.der",
            "nested-sequence.der",
            "negative-serial.der",
            "trailing-garbage.pem",
            "multiple-pem.pem",
        ];
        for name in &files {
            let data = load_degen(name);
            // Must not panic.  We use catch_unwind to turn panics
            // into failures with a clear message.
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_cert(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_cert panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken DER inputs should panic
    // parse_der
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_der_input() {
        let files = [
            "empty.der",
            "one-byte.der",
            "truncated-header.der",
            "truncated-body.der",
            "random-bytes.der",
            "null-bytes.der",
            "huge-length.der",
            "nested-sequence.der",
            "negative-serial.der",
        ];
        for name in &files {
            let data = load_degen(name);
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_der(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_der panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken PEM inputs should panic
    // parse_pem
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_pem_input() {
        let files = [
            "wrong-pem-label.pem",
            "corrupt-base64.pem",
            "trailing-garbage.pem",
            "multiple-pem.pem",
        ];
        for name in &files {
            let data = load_degen(name);
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_pem(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_pem panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: pem_to_der should also handle broken PEM inputs
    // -----------------------------------------------------------------
    #[test]
    fn pem_to_der_rejects_corrupt_base64() {
        let data = load_degen("corrupt-base64.pem");
        let result = pem_to_der(&data);
        assert!(result.is_err(), "pem_to_der must reject corrupt base64");
    }

    #[test]
    fn pem_to_der_rejects_wrong_label() {
        let data = load_degen("wrong-pem-label.pem");
        // pem_to_der extracts bytes regardless of label (it uses
        // x509_parser::pem which may or may not check).  Either
        // success or error is fine; must not panic.
        let _ = pem_to_der(&data);
    }
}

// =========================================================================
// 10. CERTIFICATE CHAIN VERIFICATION TESTS
// =========================================================================

mod verification {
    use super::*;

    fn real_cert_path(name: &str) -> std::path::PathBuf {
        let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        p.pop();
        p.push("tests");
        p.push("certs");
        p.push("real");
        p.push(name);
        p
    }

    fn load_real_cert(name: &str) -> Vec<u8> {
        std::fs::read(real_cert_path(name))
            .unwrap_or_else(|e| panic!("Failed to read real cert '{}': {}", name, e))
    }

    fn test_trust_store() -> TrustStore {
        let root_pem = load_real_cert("test-root-ca.pem");
        TrustStore::from_pem(&root_pem).expect("failed to create trust store from test root CA")
    }

    fn ec_trust_store() -> TrustStore {
        let root_pem = load_real_cert("test-ec-root-ca.pem");
        TrustStore::from_pem(&root_pem).expect("failed to create trust store from EC root CA")
    }

    // -----------------------------------------------------------------------
    // PEM chain parsing
    // -----------------------------------------------------------------------

    #[test]
    fn parse_pem_chain_single_cert() {
        let data = load_real_cert("test-root-ca.pem");
        let chain = parse_pem_chain(&data).expect("failed to parse single cert");
        assert_eq!(chain.len(), 1);
    }

    #[test]
    fn parse_pem_chain_full_chain() {
        let data = load_real_cert("test-fullchain.pem");
        let chain = parse_pem_chain(&data).expect("failed to parse full chain");
        assert_eq!(
            chain.len(),
            3,
            "full chain should have 3 certs: leaf + intermediate + root"
        );
    }

    #[test]
    fn parse_pem_chain_two_certs() {
        // server.pem + intermediate-ca.pem
        let server = load_real_cert("test-server.pem");
        let intermediate = load_real_cert("test-intermediate-ca.pem");
        let mut combined = server;
        combined.extend_from_slice(&intermediate);
        let chain = parse_pem_chain(&combined).expect("failed to parse two-cert chain");
        assert_eq!(chain.len(), 2);
    }

    #[test]
    fn parse_pem_chain_empty_input() {
        let result = parse_pem_chain(b"");
        assert!(result.is_err(), "empty input should fail");
    }

    #[test]
    fn parse_pem_chain_no_certs() {
        let result = parse_pem_chain(b"not a cert");
        assert!(result.is_err(), "non-cert input should fail");
    }

    // -----------------------------------------------------------------------
    // Trust store
    // -----------------------------------------------------------------------

    #[test]
    fn trust_store_new_is_empty() {
        let store = TrustStore::new();
        assert!(store.is_empty());
        assert_eq!(store.len(), 0);
    }

    #[test]
    fn trust_store_from_pem_single_cert() {
        let store = test_trust_store();
        assert_eq!(store.len(), 1);
        assert!(!store.is_empty());
    }

    #[test]
    fn trust_store_from_pem_bundle() {
        let data = load_real_cert("test-fullchain.pem");
        let store = TrustStore::from_pem(&data).expect("failed to load bundle");
        assert_eq!(store.len(), 3, "bundle with 3 certs should load 3 entries");
    }

    #[test]
    fn trust_store_contains_added_cert() {
        let root_pem = load_real_cert("test-root-ca.pem");
        let chain = parse_pem_chain(&root_pem).expect("parse root");
        let store = test_trust_store();
        assert!(
            store.contains(&chain[0]),
            "trust store should contain the root cert"
        );
    }

    #[test]
    fn trust_store_does_not_contain_unknown_cert() {
        let server_pem = load_real_cert("test-server.pem");
        let chain = parse_pem_chain(&server_pem).expect("parse server");
        let store = test_trust_store();
        assert!(
            !store.contains(&chain[0]),
            "trust store should not contain server cert"
        );
    }

    #[test]
    fn trust_store_system_loads() {
        let store = TrustStore::system().expect("system trust store should load");
        assert!(
            store.len() > 50,
            "system store should have many CA certs, got {}",
            store.len()
        );
    }

    // -----------------------------------------------------------------------
    // Chain verification - valid chains
    // -----------------------------------------------------------------------

    #[test]
    fn verify_valid_full_chain() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "valid full chain should verify: {:?}",
            result.errors
        );
        assert_eq!(result.chain.len(), 3);
        assert_eq!(result.errors.len(), 0);
    }

    #[test]
    fn verify_chain_without_root_uses_trust_store() {
        // Chain is leaf + intermediate; root should come from trust store
        let server = load_real_cert("test-server.pem");
        let intermediate = load_real_cert("test-intermediate-ca.pem");
        let mut chain_pem = server;
        chain_pem.extend_from_slice(&intermediate);

        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "chain without root should verify using trust store: {:?}",
            result.errors
        );
        // Chain info should include root from trust store
        assert_eq!(
            result.chain.len(),
            3,
            "chain should be extended with root from trust store"
        );
    }

    #[test]
    fn verify_valid_chain_with_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("www.example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "hostname www.example.com should match: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_valid_chain_with_san_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "hostname example.com should match SAN: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_valid_chain_with_wildcard_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("sub.example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "wildcard *.example.com should match sub.example.com: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_ec_chain() {
        let chain_pem = load_real_cert("test-ec-fullchain.pem");
        let store = ec_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "EC chain should verify: {:?}",
            result.errors
        );
        assert_eq!(result.chain.len(), 2);
    }

    #[test]
    fn verify_ec_chain_with_hostname() {
        let chain_pem = load_real_cert("test-ec-fullchain.pem");
        let store = ec_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("ec.example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "EC cert hostname should match: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_self_signed_root_in_trust_store() {
        let root_pem = load_real_cert("test-root-ca.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&root_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "self-signed root in trust store should verify: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // Chain verification - invalid chains
    // -----------------------------------------------------------------------

    #[test]
    fn verify_wrong_chain_fails_signature() {
        let chain_pem = load_real_cert("test-wrong-chain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error (just return invalid)");
        assert!(!result.is_valid, "wrong chain should not verify");
        assert!(
            result
                .errors
                .iter()
                .any(|e| e.contains("signature verification failed")),
            "should report signature failure: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_untrusted_root_fails() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        // Use a different root as trust store - the chain's root won't be in it
        let store = ec_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(!result.is_valid, "chain with untrusted root should fail");
        assert!(
            result
                .errors
                .iter()
                .any(|e| e.contains("not in the trust store")),
            "should report untrusted root: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_wrong_hostname_fails() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("wrong.example.org"))
            .expect("verification should not error");
        assert!(!result.is_valid, "wrong hostname should fail");
        assert!(
            result
                .errors
                .iter()
                .any(|e| e.contains("hostname") && e.contains("wrong.example.org")),
            "should report hostname mismatch: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_deep_wildcard_does_not_match() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        // *.example.com should NOT match deep.sub.example.com
        let result = verify_pem_chain(&chain_pem, &store, Some("deep.sub.example.com"))
            .expect("verification should not error");
        assert!(!result.is_valid, "deep subdomain should not match wildcard");
    }

    #[test]
    fn verify_self_signed_not_in_trust_store_fails() {
        let root_pem = load_real_cert("test-root-ca.pem");
        // Use EC trust store (doesn't contain RSA root)
        let store = ec_trust_store();
        let result =
            verify_pem_chain(&root_pem, &store, None).expect("verification should not error");
        assert!(
            !result.is_valid,
            "self-signed cert not in trust store should fail"
        );
    }

    #[test]
    fn verify_empty_chain_errors() {
        let store = test_trust_store();
        let result = verify_chain(&[], &store, None);
        assert!(result.is_err(), "empty chain should be an error");
    }

    #[test]
    fn verify_chain_missing_intermediate() {
        // Just the leaf, no intermediate - root can't verify it directly
        let server_pem = load_real_cert("test-server.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&server_pem, &store, None).expect("verification should not error");
        assert!(
            !result.is_valid,
            "leaf without intermediate should fail verification"
        );
    }

    // -----------------------------------------------------------------------
    // Chain verification with DER input
    // -----------------------------------------------------------------------

    #[test]
    fn verify_chain_from_der() {
        let fullchain_pem = load_real_cert("test-fullchain.pem");
        let chain_der = parse_pem_chain(&fullchain_pem).expect("parse PEM chain");
        let store = test_trust_store();
        let result = verify_chain(&chain_der, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "DER chain should verify: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // Verification result structure
    // -----------------------------------------------------------------------

    #[test]
    fn verification_result_chain_depth_ordering() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");

        for (i, cert) in result.chain.iter().enumerate() {
            assert_eq!(cert.depth, i, "chain depth should be sequential");
        }
        // Leaf at depth 0
        assert!(result.chain[0].subject.contains("www.example.com"));
        // Root at last depth
        let last = &result.chain[result.chain.len() - 1];
        assert!(last.subject.contains("Test Root CA"));
    }

    #[test]
    fn verification_result_serializes_to_json() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        let json = serde_json::to_string(&result).expect("should serialize to JSON");
        assert!(json.contains("is_valid"));
        assert!(json.contains("chain"));
    }

    // -----------------------------------------------------------------------
    // System trust store with real CA certificates
    // -----------------------------------------------------------------------

    #[test]
    fn system_trust_store_contains_real_cas() {
        let store = TrustStore::system().expect("system trust store should load");
        // System store should have a reasonable number of CAs
        assert!(
            store.len() >= 50,
            "system store has only {} CAs",
            store.len()
        );
    }

    #[test]
    fn system_trust_store_real_ca_certs_are_parseable() {
        // Load individual real CA certs extracted from system store and verify they parse
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let cert = parse_cert(&data).unwrap_or_else(|e| {
                panic!("Real CA cert {} should parse: {}", name, e);
            });
            // Real CA certs should have CA=TRUE in basic constraints
            let is_ca = cert.extensions.iter().any(|ext| {
                matches!(
                    &ext.value,
                    ExtensionValue::BasicConstraints { ca: true, .. }
                )
            });
            assert!(is_ca, "Real CA cert {} should have CA:TRUE", name);
        }
    }

    #[test]
    fn system_ca_certs_are_self_signed() {
        // Root CA certs should be self-signed (issuer == subject)
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let cert = parse_cert(&data).unwrap_or_else(|e| {
                panic!("Real CA cert {} should parse: {}", name, e);
            });
            assert_eq!(
                cert.subject.to_oneline(),
                cert.issuer.to_oneline(),
                "Root CA {} should be self-signed (subject == issuer)",
                name
            );
        }
    }

    #[test]
    fn system_ca_certs_verify_as_self_signed() {
        // Root CAs should verify their own signatures
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let chain_der = parse_pem_chain(&data).expect("parse CA cert");
            let store = TrustStore::from_pem(&data).expect("create store from CA cert");
            let result =
                verify_chain(&chain_der, &store, None).expect("verification should not error");
            assert!(
                result.is_valid,
                "Real CA cert {} should verify as self-signed: {:?}",
                name, result.errors
            );
        }
    }

    #[test]
    fn verify_chain_with_system_trust_store_and_test_chain_fails() {
        // Our test chain uses a custom root CA not in the system store
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = TrustStore::system().expect("system trust store should load");
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        // Our test root is NOT in the system store, so this should fail
        assert!(
            !result.is_valid,
            "test chain should not verify against system store (custom root CA)"
        );
    }
}

// ===========================================================================
// Cross-compatibility tests using public test vectors
// ===========================================================================
//
// Test certificates sourced from:
//   - x509-parser (MIT/Apache-2.0): https://github.com/rusticata/x509-parser/tree/master/assets
//   - OpenSSL (Apache-2.0): https://github.com/openssl/openssl/tree/master/test/certs
//   - pyca/cryptography (Apache-2.0/BSD): https://github.com/pyca/cryptography
//
// Reference values extracted with `openssl x509` for cross-implementation verification.

fn load_external(name: &str) -> Vec<u8> {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop();
    p.push("tests");
    p.push("certs");
    p.push("external");
    p.push(name);
    std::fs::read(&p)
        .unwrap_or_else(|e| panic!("Failed to read external test cert '{}': {}", name, e))
}

/// Helper: parse an external cert from PEM.
fn parse_external_pem(name: &str) -> CertificateInfo {
    let data = load_external(name);
    parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse '{}': {}", name, e))
}

/// Helper: parse an external cert from DER.
fn parse_external_der(name: &str) -> CertificateInfo {
    let data = load_external(name);
    parse_der(&data).unwrap_or_else(|e| panic!("Failed to parse '{}': {}", name, e))
}

mod cross_compat_openssl {
    //! Tests against OpenSSL test suite certificates.
    use super::*;

    #[test]
    fn ossl_rsa_root_ca() {
        let cert = parse_external_pem("ossl-root-cert.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = Root CA"));
        assert!(cert.issuer_string().contains("CN = Root CA"));
        assert_eq!(cert.serial, "01");
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "BB:84:C7:81:92:4C:01:36:5E:65:AE:27:CE:26:DF:D5:D4:B8:F2:FD:57:60:CD:27:D3:0F:E7:8E:5A:B7:3F:1A"
        );
    }

    #[test]
    fn ossl_rsa_root_pubkey_pem() {
        let cert = parse_external_pem("ossl-root-cert.pem");
        let pem = cert.public_key_pem();
        assert!(pem.starts_with("-----BEGIN PUBLIC KEY-----"));
        assert!(pem.contains("MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBC"));
    }

    #[test]
    fn ossl_ecdsa_p256() {
        let cert = parse_external_pem("ossl-server-ecdsa-cert.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = Server ECDSA cert"));
        assert!(cert.issuer_string().contains("CN = Root CA"));
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(cert.public_key.key_size, Some(256));
        assert_eq!(cert.public_key.curve.as_deref(), Some("P-256"));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "E7:01:D8:30:25:6E:1B:E8:B2:0A:85:46:56:E6:C4:7A:38:37:BB:4E:59:B7:1D:8E:83:63:3B:15:EC:61:1D:3B"
        );
    }

    #[test]
    fn ossl_ecdsa_p256_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("ossl-server-ecdsa-cert.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4js03ETjze0nIgpPoo5AzlmV+uKC
HXYERwfGfOm52BUdgDhovkPkm6VgYXMvQtDlDnkakK5vVXaP4CHIEwo9Cg==
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn ossl_ed25519() {
        let cert = parse_external_pem("ossl-root-ed25519.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = IETF Test Demo"));
        assert!(cert.issuer_string().contains("CN = IETF Test Demo"));
        assert_eq!(cert.serial, "84:F1:08:3D:1C:E3:2D:95");
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert_eq!(cert.public_key.key_size, Some(256));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "A5:8E:62:33:C6:61:0A:1F:B1:DE:35:EE:33:AD:57:A2:50:D1:FE:2B:E7:62:E1:41:50:E6:B9:3A:E2:25:80:A3"
        );
    }

    #[test]
    fn ossl_ed25519_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("ossl-root-ed25519.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn ossl_ed448() {
        let cert = parse_external_pem("ossl-root-ed448-cert.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = Root Ed448"));
        assert_eq!(cert.public_key.algorithm, "Ed448");
        assert_eq!(cert.public_key.key_size, Some(448));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "6C:11:DC:C0:EE:96:65:07:17:D0:E9:16:08:D8:CF:BC:7A:26:C2:CF:57:CC:41:5F:B7:5A:94:9F:F1:20:AC:A9"
        );
    }

    #[test]
    fn ossl_ed448_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("ossl-root-ed448-cert.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MEMwBQYDK2VxAzoAbbhuwNA/rdlgdLSyTJ6WaCVNO1gzccKiKW6pCADMMcMBCNiQ
qWSt4EIbHpqDc+eWoiKbG6t7tjUA
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn ossl_many_names_parses_without_panic() {
        let cert = parse_external_pem("ossl-many-names1.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = t0.test"));
        // This cert has 513 emailAddress attributes in the subject
        let email_count = cert
            .subject
            .components
            .iter()
            .filter(|(k, _)| k == "emailAddress")
            .count();
        assert!(
            email_count > 100,
            "expected many emailAddress components, got {}",
            email_count
        );
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "CC:14:A3:C9:50:39:2F:32:49:A3:C6:7A:FA:66:8F:29:70:B4:45:03:6B:7A:6E:11:A6:3F:BF:C8:B6:3D:D2:97"
        );
    }
}

mod cross_compat_pyca {
    //! Tests against pyca/cryptography test vectors.
    use super::*;

    #[test]
    fn pyca_ecdsa_p384_root() {
        let cert = parse_external_pem("pyca-ecdsa-root.pem");
        assert_eq!(cert.version, 3);
        assert!(cert
            .subject_string()
            .contains("CN = DigiCert Global Root G3"));
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(cert.public_key.key_size, Some(384));
        assert_eq!(cert.public_key.curve.as_deref(), Some("P-384"));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "31:AD:66:48:F8:10:41:38:C7:38:F3:9E:A4:32:01:33:39:3E:3A:18:CC:02:29:6E:F9:7C:2A:C9:EF:67:31:D0"
        );
    }

    #[test]
    fn pyca_ecdsa_p384_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("pyca-ecdsa-root.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOre
xpu80JX28MzQC7phW1FGfp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0D
Q+4QE2xy3q6Ip6FrtUPOZ9wj/wMco+I+
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn pyca_letsencrypt_x3() {
        let cert = parse_external_pem("pyca-letsencrypt-x3.pem");
        assert_eq!(cert.version, 3);
        assert!(cert
            .subject_string()
            .contains("CN = Let's Encrypt Authority X3"));
        assert!(cert.issuer_string().contains("CN = DST Root CA X3"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "25:84:7D:66:8E:B4:F0:4F:DD:40:B1:2B:6B:07:40:C5:67:DA:7D:02:43:08:EB:6C:2C:96:FE:41:D9:DE:21:8D"
        );
    }

    #[test]
    fn pyca_v1_cert() {
        let cert = parse_external_pem("pyca-v1.pem");
        assert_eq!(cert.version, 1);
        assert!(cert.subject_string().contains("CN = SSLeay/rsa test cert"));
        assert!(cert.issuer_string().contains("CN = SSLeay/rsa test CA"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(512));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "5B:7C:4E:9F:7E:70:16:2F:CC:12:A8:D2:41:6D:AE:35:12:73:97:9F:0E:D0:C9:7D:0F:F1:26:FD:73:A7:EE:66"
        );
        // v1 certs have no extensions
        assert!(cert.extensions.is_empty());
    }

    #[test]
    fn pyca_wildcard_san() {
        let cert = parse_external_pem("pyca-wildcard-san.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = *.langui.sh"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(4096));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "68:98:6E:4D:DA:05:76:BF:E3:61:A7:90:EE:A9:E0:16:15:F6:88:30:4C:17:69:22:1C:73:7E:2B:FD:39:2E:CE"
        );
        // Check wildcard SAN entries
        let san: Vec<_> = cert.san_entries();
        assert!(!san.is_empty());
        let dns_names: Vec<_> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Dns(n) => Some(n.as_str()),
                _ => None,
            })
            .collect();
        assert!(dns_names.contains(&"*.langui.sh"));
    }

    #[test]
    fn pyca_utf8_dnsname() {
        let cert = parse_external_pem("pyca-utf8-dnsname.pem");
        assert_eq!(cert.version, 3);
        // Subject contains UTF-8 characters
        assert!(cert.subject_string().contains("partner.biztositas.hu"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "FC:3E:3A:A4:21:D3:75:AB:E0:1E:6B:68:13:2C:C0:96:EE:66:24:19:EA:80:84:CC:8E:FC:4A:94:99:57:D6:8E"
        );
    }

    #[test]
    fn pyca_dsa_selfsigned() {
        let cert = parse_external_pem("pyca-dsa-selfsigned.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = PyCA DSA CA"));
        // DSA is not one of our named algorithms so it falls back to OID
        assert!(
            cert.public_key.algorithm == "DSA"
                || cert.public_key.algorithm.contains("1.2.840.10040.4.1"),
            "expected DSA or DSA OID, got '{}'",
            cert.public_key.algorithm
        );
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "0A:A0:FD:DB:5B:87:8E:EE:B5:92:FB:7F:12:2C:A0:05:BC:3B:63:A3:C4:D8:A7:E9:6B:89:CA:B1:FB:5E:70:7F"
        );
    }
}

mod cross_compat_x509_parser {
    //! Tests against x509-parser's own test assets.
    use super::*;

    #[test]
    fn x509p_pem_and_der_produce_same_fingerprint() {
        let pem_cert = parse_external_pem("x509p-certificate.pem");
        let der_cert = parse_external_der("x509p-certificate.der");
        assert_eq!(
            pem_cert.fingerprint(DigestAlgorithm::Sha256),
            der_cert.fingerprint(DigestAlgorithm::Sha256),
        );
        assert_eq!(pem_cert.serial, der_cert.serial);
        assert_eq!(pem_cert.subject_string(), der_cert.subject_string());
    }

    #[test]
    fn x509p_certificate_pem() {
        let cert = parse_external_pem("x509p-certificate.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = lists.for-our.info"));
        assert!(cert
            .issuer_string()
            .contains("CN = Let's Encrypt Authority X3"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "8F:A4:CB:4E:93:8B:5A:85:5F:B1:49:7F:A2:88:AC:55:72:3E:01:09:D0:51:8B:50:54:81:34:8D:EC:0D:E4:71"
        );
    }

    #[test]
    fn x509p_igc_a_french_gov_root() {
        let cert = parse_external_pem("x509p-IGC_A.pem");
        assert_eq!(cert.version, 3);
        // French government root CA with rich DN
        assert!(cert.subject_string().contains("CN = IGC/A"));
        assert!(cert.subject_string().contains("C = FR"));
        assert!(cert.subject_string().contains("O = PM/SGDN"));
        assert!(cert.subject_string().contains("OU = DCSSI"));
        // Self-signed
        assert_eq!(cert.subject_string(), cert.issuer_string());
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "B9:BE:A7:86:0A:96:2E:A3:61:1D:AB:97:AB:6D:A3:E2:1C:10:68:B9:7D:55:57:5E:D0:E1:12:79:C1:1C:89:32"
        );
    }

    #[test]
    fn x509p_igc_a_der_matches_pem() {
        let pem_cert = parse_external_pem("x509p-IGC_A.pem");
        let der_cert = parse_external_der("x509p-IGC_A.der");
        assert_eq!(
            pem_cert.fingerprint(DigestAlgorithm::Sha256),
            der_cert.fingerprint(DigestAlgorithm::Sha256),
        );
        assert_eq!(pem_cert.subject_string(), der_cert.subject_string());
        assert_eq!(pem_cert.serial, der_cert.serial);
    }

    #[test]
    fn x509p_no_extensions() {
        let cert = parse_external_pem("x509p-no_extensions.pem");
        assert!(cert.subject_string().contains("CN = benno"));
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(cert.public_key.key_size, Some(384));
        assert!(cert.extensions.is_empty());
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "39:F4:1F:F9:38:5A:90:DF:31:A9:0F:C6:C0:C6:86:CF:23:43:DE:A2:F1:8C:D0:58:33:9A:0D:00:A0:7A:51:CB"
        );
    }

    #[test]
    fn x509p_no_extensions_der_matches_pem() {
        let pem_cert = parse_external_pem("x509p-no_extensions.pem");
        let der_cert = parse_external_der("x509p-no_extensions.der");
        assert_eq!(
            pem_cert.fingerprint(DigestAlgorithm::Sha256),
            der_cert.fingerprint(DigestAlgorithm::Sha256),
        );
    }

    #[test]
    fn x509p_ed25519_der() {
        let cert = parse_external_der("x509p-ed25519.der");
        assert!(cert.subject_string().contains("CN = www.example.com"));
        assert!(cert.subject_string().contains("C = DE"));
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert_eq!(cert.public_key.key_size, Some(256));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "D3:86:93:B6:76:F3:B8:0B:18:3E:7A:B6:1D:14:18:2A:9D:20:7C:13:1A:35:ED:67:69:6C:F8:95:59:72:55:1D"
        );
    }

    #[test]
    fn x509p_v1_cert() {
        let cert = parse_external_der("x509p-v1.der");
        assert_eq!(cert.version, 1);
        assert!(cert.subject_string().contains("CN = marquee"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert!(cert.extensions.is_empty());
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "3D:6D:A6:82:D3:30:93:D8:5A:A6:32:84:6B:A9:FA:BF:31:FE:90:ED:C0:91:A2:7F:D7:F6:2E:51:4F:85:8C:57"
        );
    }
}

mod cross_compat_conversion {
    //! Roundtrip conversion tests on external certificates.
    use super::*;

    #[test]
    fn ossl_rsa_pem_to_der_roundtrip() {
        let pem_data = load_external("ossl-root-cert.pem");
        let der_bytes = pem_to_der(&pem_data).unwrap();
        let pem_string = der_to_pem(&der_bytes);
        let re_der = pem_to_der(pem_string.as_bytes()).unwrap();
        assert_eq!(der_bytes, re_der);
        // Fingerprints must match
        let cert1 = parse_pem(&pem_data).unwrap();
        let cert2 = parse_der(&der_bytes).unwrap();
        assert_eq!(
            cert1.fingerprint(DigestAlgorithm::Sha256),
            cert2.fingerprint(DigestAlgorithm::Sha256),
        );
    }

    #[test]
    fn ossl_ed25519_pem_to_der_roundtrip() {
        let pem_data = load_external("ossl-root-ed25519.pem");
        let der_bytes = pem_to_der(&pem_data).unwrap();
        let pem_string = der_to_pem(&der_bytes);
        let re_der = pem_to_der(pem_string.as_bytes()).unwrap();
        assert_eq!(der_bytes, re_der);
    }

    #[test]
    fn x509p_der_to_pem_roundtrip() {
        let der_data = load_external("x509p-certificate.der");
        let pem_string = der_to_pem(&der_data);
        let re_der = pem_to_der(pem_string.as_bytes()).unwrap();
        assert_eq!(der_data, re_der);
    }

    #[test]
    fn pyca_letsencrypt_pem_to_der_roundtrip() {
        let pem_data = load_external("pyca-letsencrypt-x3.pem");
        let der_bytes = pem_to_der(&pem_data).unwrap();
        let pem_string = der_to_pem(&der_bytes);
        let re_der = pem_to_der(pem_string.as_bytes()).unwrap();
        assert_eq!(der_bytes, re_der);
    }
}

mod cross_compat_auto_detect {
    //! Verify that auto-detection (parse_cert) works for all external formats.
    use super::*;

    #[test]
    fn auto_detect_all_pem_files() {
        let pem_files = [
            "ossl-root-cert.pem",
            "ossl-server-ecdsa-cert.pem",
            "ossl-root-ed25519.pem",
            "ossl-root-ed448-cert.pem",
            "ossl-many-names1.pem",
            "pyca-ecdsa-root.pem",
            "pyca-v1.pem",
            "pyca-letsencrypt-x3.pem",
            "pyca-wildcard-san.pem",
            "pyca-utf8-dnsname.pem",
            "pyca-dsa-selfsigned.pem",
            "x509p-certificate.pem",
            "x509p-IGC_A.pem",
            "x509p-no_extensions.pem",
        ];
        for name in &pem_files {
            let data = load_external(name);
            let cert = parse_cert(&data)
                .unwrap_or_else(|e| panic!("parse_cert failed on PEM file '{}': {}", name, e));
            assert!(
                cert.version >= 1 && cert.version <= 3,
                "bad version in {}",
                name
            );
            assert!(!cert.serial.is_empty(), "empty serial in {}", name);
            assert!(
                !cert.subject_string().is_empty(),
                "empty subject in {}",
                name
            );
        }
    }

    #[test]
    fn auto_detect_all_der_files() {
        let der_files = [
            "x509p-certificate.der",
            "x509p-IGC_A.der",
            "x509p-no_extensions.der",
            "x509p-ed25519.der",
            "x509p-v1.der",
        ];
        for name in &der_files {
            let data = load_external(name);
            let cert = parse_cert(&data)
                .unwrap_or_else(|e| panic!("parse_cert failed on DER file '{}': {}", name, e));
            assert!(
                cert.version >= 1 && cert.version <= 3,
                "bad version in {}",
                name
            );
            assert!(!cert.serial.is_empty(), "empty serial in {}", name);
        }
    }

    #[test]
    fn display_and_json_work_for_all_external_certs() {
        let all_pem = [
            "ossl-root-cert.pem",
            "ossl-server-ecdsa-cert.pem",
            "ossl-root-ed25519.pem",
            "ossl-root-ed448-cert.pem",
            "pyca-ecdsa-root.pem",
            "pyca-v1.pem",
            "pyca-letsencrypt-x3.pem",
            "pyca-dsa-selfsigned.pem",
            "x509p-certificate.pem",
            "x509p-IGC_A.pem",
            "x509p-no_extensions.pem",
        ];
        for name in &all_pem {
            let data = load_external(name);
            let cert = parse_cert(&data).unwrap();
            let text = display_text(&cert, true);
            assert!(
                text.contains("Certificate:"),
                "display_text broken for {}",
                name
            );
            let json =
                to_json(&cert).unwrap_or_else(|e| panic!("to_json failed for '{}': {}", name, e));
            assert!(
                json.contains("version"),
                "JSON missing version for {}",
                name
            );
        }
    }
}

// =========================================================================
// REFERENCE TEST VECTORS
// =========================================================================
//
// Compare library output against OpenSSL-generated reference files in
// tests/certs/reference/ for regression detection.

mod reference_vectors {
    use super::*;

    /// Normalize an OpenSSL serial like "1000" or "01" to our colon-separated
    /// format. OpenSSL outputs uppercase hex without colons; our library uses
    /// colon-separated pairs.
    fn normalize_serial(openssl_serial: &str) -> String {
        let hex = openssl_serial.trim().to_ascii_uppercase();
        // Pad to even length
        let hex = if !hex.len().is_multiple_of(2) {
            format!("0{}", hex)
        } else {
            hex
        };
        hex.as_bytes()
            .chunks(2)
            .map(|c| std::str::from_utf8(c).unwrap_or(""))
            .collect::<Vec<_>>()
            .join(":")
    }

    /// Parse OpenSSL fingerprint like "sha256 Fingerprint=AA:BB:CC:..."
    /// Returns just the "AA:BB:CC:..." part.
    fn parse_fingerprint(line: &str) -> &str {
        line.split('=').nth(1).unwrap_or(line).trim()
    }

    /// Parse OpenSSL subject/issuer like "subject=C = US, ST = California, ..."
    /// into a list of (key, value) pairs. OpenSSL uses spaces around `=`.
    fn parse_dn_components(line: &str) -> Vec<(String, String)> {
        // Strip "subject=" or "issuer=" prefix
        let dn_str = line.split_once('=').map(|(_, v)| v).unwrap_or(line);
        let mut components = Vec::new();
        for part in dn_str.split(", ") {
            if let Some((key, val)) = part.split_once(" = ") {
                components.push((key.trim().to_string(), val.trim().to_string()));
            }
        }
        components
    }

    /// Test data: (cert_file, reference_prefix)
    const CERTS: &[(&str, &str)] = &[
        ("root-ca.pem", "root-ca"),
        ("intermediate-ca.pem", "intermediate-ca"),
        ("server.pem", "server"),
        ("client.pem", "client"),
        ("ec-p256.pem", "ec-p256"),
        ("ec-p384.pem", "ec-p384"),
        ("ed25519.pem", "ed25519"),
        ("expired.pem", "expired"),
        ("many-extensions.pem", "many-extensions"),
        ("minimal.pem", "minimal"),
    ];

    #[test]
    fn serial_matches_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-serial.txt", prefix));
            // OpenSSL format: "serial=XX"
            let ref_serial = ref_line.strip_prefix("serial=").unwrap_or(&ref_line);
            let expected = normalize_serial(ref_serial);
            let actual = cert.serial_hex().to_ascii_uppercase();

            assert_eq!(
                actual, expected,
                "serial mismatch for {}: got '{}', expected '{}'",
                cert_file, actual, expected
            );
        }
    }

    #[test]
    fn sha256_fingerprint_matches_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-fingerprint-sha256.txt", prefix));
            let expected = parse_fingerprint(&ref_line);
            let actual = cert.fingerprint(DigestAlgorithm::Sha256);

            assert_eq!(
                actual, expected,
                "SHA-256 fingerprint mismatch for {}",
                cert_file
            );
        }
    }

    #[test]
    fn sha1_fingerprint_matches_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-fingerprint-sha1.txt", prefix));
            let expected = parse_fingerprint(&ref_line);
            let actual = cert.fingerprint(DigestAlgorithm::Sha1);

            assert_eq!(
                actual, expected,
                "SHA-1 fingerprint mismatch for {}",
                cert_file
            );
        }
    }

    #[test]
    fn subject_components_match_reference() {
        // Only test ASCII subjects (skip utf8-subject which has encoding differences)
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-subject.txt", prefix));
            let ref_components = parse_dn_components(&ref_line);

            for (ref_key, ref_val) in &ref_components {
                let found = cert
                    .subject
                    .components
                    .iter()
                    .any(|(k, v)| k == ref_key && v == ref_val);
                assert!(
                    found,
                    "subject component {}={} from reference not found in {} (got: {})",
                    ref_key,
                    ref_val,
                    cert_file,
                    cert.subject_string()
                );
            }

            assert_eq!(
                cert.subject.components.len(),
                ref_components.len(),
                "subject component count mismatch for {} (got {}: {}, expected {}: {:?})",
                cert_file,
                cert.subject.components.len(),
                cert.subject_string(),
                ref_components.len(),
                ref_components,
            );
        }
    }

    #[test]
    fn issuer_components_match_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-issuer.txt", prefix));
            let ref_components = parse_dn_components(&ref_line);

            for (ref_key, ref_val) in &ref_components {
                let found = cert
                    .issuer
                    .components
                    .iter()
                    .any(|(k, v)| k == ref_key && v == ref_val);
                assert!(
                    found,
                    "issuer component {}={} from reference not found in {} (got: {})",
                    ref_key,
                    ref_val,
                    cert_file,
                    cert.issuer_string()
                );
            }

            assert_eq!(
                cert.issuer.components.len(),
                ref_components.len(),
                "issuer component count mismatch for {}",
                cert_file,
            );
        }
    }

    #[test]
    fn server_modulus_matches_reference() {
        let data = load_cert("server.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_line = load_reference("server-modulus.txt");
        // OpenSSL format: "Modulus=AABB..."
        let expected = ref_line
            .strip_prefix("Modulus=")
            .unwrap_or(&ref_line)
            .to_ascii_uppercase();

        let actual = cert
            .modulus_hex()
            .expect("server cert should have RSA modulus")
            .to_ascii_uppercase();

        assert_eq!(actual, expected, "modulus mismatch for server.pem");
    }

    #[test]
    fn server_email_matches_reference() {
        let data = load_cert("server.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_email = load_reference("server-email.txt");
        let emails = cert.emails();

        assert!(
            emails.iter().any(|e| e == &ref_email),
            "expected email '{}' not found in server.pem emails: {:?}",
            ref_email,
            emails
        );
    }

    #[test]
    fn server_ocsp_uri_matches_reference() {
        let data = load_cert("server.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_uri = load_reference("server-ocsp-uri.txt");
        let ocsp_urls = cert.ocsp_urls();

        assert!(
            ocsp_urls.iter().any(|u| u == &ref_uri),
            "expected OCSP URI '{}' not found in server.pem: {:?}",
            ref_uri,
            ocsp_urls
        );
    }

    #[test]
    fn client_email_matches_reference() {
        let data = load_cert("client.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_email = load_reference("client-email.txt");
        let emails = cert.emails();

        assert!(
            emails.iter().any(|e| e == &ref_email),
            "expected email '{}' not found in client.pem emails: {:?}",
            ref_email,
            emails
        );
    }
}
