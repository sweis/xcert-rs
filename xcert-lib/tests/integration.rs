#![allow(
    clippy::expect_used,
    clippy::unwrap_used,
    clippy::panic,
    clippy::indexing_slicing
)]
//! Integration tests for xcert-lib using generated test certificates.
//!
//! Test certificates are in tests/certs/ (generated by tests/certs/generate.sh).
//! Reference outputs from openssl x509 are in tests/certs/reference/.
//!
//! These tests exercise the library API against known-good certificates and
//! compare results to openssl x509 output where applicable.

use xcert_lib::*;

// ---------------------------------------------------------------------------
// Helper: load a test certificate file
// ---------------------------------------------------------------------------

fn cert_path(name: &str) -> std::path::PathBuf {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop(); // up from xcert-lib to workspace root
    p.push("tests");
    p.push("certs");
    p.push(name);
    p
}

fn reference_path(name: &str) -> std::path::PathBuf {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop(); // up from xcert-lib to workspace root
    p.push("tests");
    p.push("certs");
    p.push("reference");
    p.push(name);
    p
}

fn load_reference(name: &str) -> String {
    std::fs::read_to_string(reference_path(name))
        .unwrap_or_else(|e| panic!("Failed to read reference '{}': {}", name, e))
        .trim()
        .to_string()
}

fn load_cert(name: &str) -> Vec<u8> {
    std::fs::read(cert_path(name)).unwrap_or_else(|e| {
        panic!(
            "Failed to read test certificate '{}': {}. Run tests/certs/generate.sh first.",
            name, e
        )
    })
}

// =========================================================================
// 1. PARSING TESTS
// =========================================================================

mod parsing {
    use super::*;

    #[test]
    fn parse_rsa_pem() {
        let data = load_cert("root-ca.pem");
        let cert = parse_pem(&data).expect("should parse root CA PEM");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_rsa_der() {
        let data = load_cert("root-ca.der");
        let cert = parse_der(&data).expect("should parse root CA DER");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_pem() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).expect("should auto-detect PEM and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_der() {
        let data = load_cert("server.der");
        let cert = parse_cert(&data).expect("should auto-detect DER and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_minimal_self_signed() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).expect("should parse minimal cert");
        // Minimal cert created with -subj "/CN=Minimal Test"
        assert!(cert.subject_string().contains("Minimal Test"));
    }

    #[test]
    fn parse_expired_cert() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).expect("should parse expired cert");
        assert!(cert.subject_string().contains("Expired Test"));
    }

    #[test]
    fn parse_many_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).expect("should parse cert with many extensions");
        assert!(!cert.extensions.is_empty(), "should have extensions");
    }

    #[test]
    fn parse_utf8_subject() {
        let data = load_cert("utf8-subject.pem");
        let cert = parse_cert(&data).expect("should parse cert with UTF-8 subject");
        // Should contain French characters
        let subject = cert.subject_string();
        assert!(
            subject.contains("Paris") || subject.contains("France"),
            "UTF-8 subject should contain French location, got: {}",
            subject
        );
    }

    #[test]
    fn parse_chain_takes_first_cert() {
        let data = load_cert("chain.pem");
        let cert = parse_cert(&data).expect("should parse first cert in chain");
        // chain.pem = server + intermediate + root; first should be server
        assert!(cert.subject_string().contains("www.example.com"));
    }

    #[test]
    fn parse_invalid_data_returns_error() {
        let data = b"this is not a certificate";
        assert!(parse_cert(data).is_err());
    }

    #[test]
    fn parse_truncated_der_returns_error() {
        let data = load_cert("root-ca.der");
        let truncated = &data[..data.len() / 2];
        assert!(parse_der(truncated).is_err());
    }
}

// =========================================================================
// 2. FIELD EXTRACTION TESTS
// =========================================================================

mod fields {
    use super::*;

    // --- Issuer ---

    #[test]
    fn root_ca_is_self_signed() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(
            cert.subject_string(),
            cert.issuer_string(),
            "root CA should be self-signed"
        );
    }

    // --- Dates ---

    #[test]
    fn server_dates_are_reasonable() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // not_before should be in 2026
        assert!(
            cert.not_before_string().contains("2026"),
            "not_before: {}",
            cert.not_before_string()
        );
        // not_after should be in 2101 (75 year validity)
        assert!(
            cert.not_after_string().contains("2101"),
            "not_after: {}",
            cert.not_after_string()
        );
    }

    #[test]
    fn expired_cert_dates() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // The expired cert has 1-day validity
        let not_before = cert.not_before_string();
        let not_after = cert.not_after_string();
        assert!(!not_before.is_empty(), "not_before should not be empty");
        assert!(!not_after.is_empty(), "not_after should not be empty");
    }

    // --- Public Key Info ---

    #[test]
    fn public_key_pem_format() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let pem = cert.public_key_pem();
        assert!(
            pem.contains("BEGIN PUBLIC KEY"),
            "public key PEM should have header"
        );
        assert!(
            pem.contains("END PUBLIC KEY"),
            "public key PEM should have footer"
        );
    }

    // --- Signature Algorithm ---

    #[test]
    fn server_sha256_rsa_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha256")
                || cert.signature_algorithm.contains("SHA256")
                || cert.signature_algorithm.contains("sha256WithRSAEncryption"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }

    #[test]
    fn ec_p384_sha384_signature() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha384")
                || cert.signature_algorithm.contains("SHA384")
                || cert.signature_algorithm.contains("ecdsa-with-SHA384"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }
}

// =========================================================================
// 3. EXTENSION TESTS
// =========================================================================

mod extensions {
    use super::*;

    #[test]
    fn root_ca_is_ca() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "root CA should have BasicConstraints");
        if let Some(ext) = bc {
            assert!(ext.critical, "BasicConstraints should be critical on CA");
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(ca, "CA flag should be true");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn intermediate_ca_pathlen_zero() {
        let data = load_cert("intermediate-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "intermediate CA should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, path_len } => {
                    assert!(ca, "CA flag should be true");
                    assert_eq!(*path_len, Some(0), "pathlen should be 0");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_not_ca() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "server should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(!ca, "server CA flag should be false");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "server should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter()
                .any(|u| u.contains("Digital Signature") || u.contains("digitalSignature")),
            "should include Digital Signature, got: {:?}",
            ku
        );
        assert!(
            ku.iter()
                .any(|u| u.contains("Key Encipherment") || u.contains("keyEncipherment")),
            "should include Key Encipherment, got: {:?}",
            ku
        );
    }

    #[test]
    fn server_extended_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "server should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter()
                .any(|u| u.contains("Server") || u.contains("serverAuth")),
            "should include serverAuth, got: {:?}",
            eku
        );
    }

    #[test]
    fn client_extended_key_usage() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "client should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter()
                .any(|u| u.contains("Client") || u.contains("clientAuth")),
            "should include clientAuth, got: {:?}",
            eku
        );
        assert!(
            eku.iter()
                .any(|u| u.contains("mail") || u.contains("emailProtection")),
            "should include emailProtection, got: {:?}",
            eku
        );
    }

    #[test]
    fn server_san_dns_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        assert!(!san.is_empty(), "server should have SAN entries");

        let dns_names: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Dns(name) => Some(name.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            dns_names.contains(&"www.example.com"),
            "should contain www.example.com, got: {:?}",
            dns_names
        );
        assert!(
            dns_names.contains(&"example.com"),
            "should contain example.com"
        );
        assert!(
            dns_names.contains(&"*.example.com"),
            "should contain *.example.com"
        );
    }

    #[test]
    fn server_san_ip_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let ips: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Ip(ip) => Some(ip.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            ips.iter().any(|ip| ip.contains("93.184.216.34")),
            "should contain IPv4 93.184.216.34, got: {:?}",
            ips
        );
        // IPv6 address
        assert!(
            ips.iter().any(|ip| ip.to_lowercase().contains("2606:2800")),
            "should contain IPv6 address, got: {:?}",
            ips
        );
    }

    #[test]
    fn server_san_email_entry() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let emails: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Email(email) => Some(email.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            emails.contains(&"admin@example.com"),
            "should contain admin@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn many_extensions_cert_has_expected_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();

        let ext_names: Vec<&str> = cert.extensions.iter().map(|e| e.name.as_str()).collect();

        // Should have at least: BasicConstraints, KeyUsage, ExtendedKeyUsage, SKI, AKI, SAN, AIA, CRL DP
        assert!(
            ext_names.iter().any(|n| n.contains("Basic")),
            "should have BasicConstraints"
        );
        assert!(
            ext_names
                .iter()
                .any(|n| n.contains("Key Usage") && !n.contains("Extended")),
            "should have KeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Extended")),
            "should have ExtendedKeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Subject Alternative")),
            "should have SubjectAltName"
        );
        assert!(
            ext_names
                .iter()
                .any(|n| n.contains("Authority Information")),
            "should have AuthorityInfoAccess"
        );
    }

    #[test]
    fn many_extensions_eku_values() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some());
        let eku = eku.unwrap();
        // Should include: serverAuth, clientAuth, codeSigning, emailProtection, timeStamping
        assert!(
            eku.len() >= 5,
            "should have at least 5 EKU values, got {} : {:?}",
            eku.len(),
            eku
        );
    }

    #[test]
    fn many_extensions_san_has_uri() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let uris: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Uri(u) => Some(u.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            uris.iter().any(|u| u.contains("example.com/cert-info")),
            "should contain URI SAN, got: {:?}",
            uris
        );
    }

    #[test]
    fn root_ca_key_usage_includes_cert_sign() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "root CA should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter().any(|u| u.contains("Cert Sign")
                || u.contains("keyCertSign")
                || u.contains("Certificate Sign")),
            "root CA should have keyCertSign, got: {:?}",
            ku
        );
    }

    #[test]
    fn minimal_cert_has_no_san() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        // A minimal self-signed cert may or may not have SAN depending on openssl defaults
        // But our explicitly minimal cert should have minimal extensions
        // This is a structural test -- we mainly verify it doesn't crash
        let _ = san;
    }
}

// =========================================================================
// 4. FINGERPRINT TESTS
// =========================================================================

mod fingerprints {
    use super::*;

    #[test]
    fn fingerprint_from_pem_matches_der() {
        let pem_data = load_cert("root-ca.pem");
        let der_data = load_cert("root-ca.der");
        let pem_cert = parse_pem(&pem_data).unwrap();
        let der_cert = parse_der(&der_data).unwrap();
        assert_eq!(
            pem_cert.fingerprint(DigestAlgorithm::Sha256),
            der_cert.fingerprint(DigestAlgorithm::Sha256),
            "PEM and DER should produce the same fingerprint"
        );
    }

    #[test]
    fn sha384_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha384);
        // SHA-384 = 48 bytes = 48*3-1 = 143 chars in colon-separated hex
        assert_eq!(fp.len(), 143, "SHA-384 fingerprint wrong length: {}", fp);
    }

    #[test]
    fn sha512_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha512);
        // SHA-512 = 64 bytes = 64*3-1 = 191 chars in colon-separated hex
        assert_eq!(fp.len(), 191, "SHA-512 fingerprint wrong length: {}", fp);
    }
}

// =========================================================================
// 5. EMAIL EXTRACTION TESTS
// =========================================================================

mod emails {
    use super::*;

    #[test]
    fn root_ca_no_emails() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(emails.is_empty(), "root CA should have no emails");
    }
}

// =========================================================================
// 6. CHECK TESTS
// =========================================================================

mod checks {
    use super::*;

    // --- Expiry ---

    #[test]
    fn server_not_expired() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // Server cert valid until 2101; checking with 0 seconds means "is it valid now?"
        assert!(check_expiry(&cert, 0), "server cert should not be expired");
    }

    #[test]
    fn server_valid_for_one_year() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_expiry(&cert, 365 * 24 * 60 * 60),
            "server cert should be valid for at least 1 year"
        );
    }

    #[test]
    fn expired_cert_is_expired() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // Check if it expires within 10 years (it already has since it was 1-day)
        assert!(
            !check_expiry(&cert, 315_360_000),
            "expired cert should be detected as expiring"
        );
    }

    // --- Hostname ---

    #[test]
    fn hostname_exact_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "www.example.com"),
            "should match www.example.com"
        );
    }

    #[test]
    fn hostname_bare_domain_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "example.com"),
            "should match example.com (in SAN)"
        );
    }

    #[test]
    fn hostname_wildcard_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "sub.example.com"),
            "should match *.example.com wildcard"
        );
    }

    #[test]
    fn hostname_wildcard_does_not_match_deep_subdomain() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "deep.sub.example.com"),
            "wildcard should not match deep.sub.example.com"
        );
    }

    #[test]
    fn hostname_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "bad.example.org"),
            "should not match bad.example.org"
        );
    }

    #[test]
    fn hostname_case_insensitive() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "WWW.EXAMPLE.COM"),
            "hostname matching should be case-insensitive"
        );
    }

    // --- IP ---

    #[test]
    fn ip_v4_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "93.184.216.34"),
            "should match IPv4 93.184.216.34"
        );
    }

    #[test]
    fn ip_v4_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(!check_ip(&cert, "1.2.3.4"), "should not match 1.2.3.4");
    }

    #[test]
    fn ip_v6_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "2606:2800:220:1:248:1893:25c8:1946"),
            "should match IPv6 address"
        );
    }

    // --- Email ---

    #[test]
    fn email_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_email(&cert, "nobody@bad.com"),
            "should not match nobody@bad.com"
        );
    }
}

// =========================================================================
// 7. CONVERSION TESTS
// =========================================================================

mod conversion {
    use super::*;

    #[test]
    fn pem_to_der_conversion() {
        let pem_data = load_cert("root-ca.pem");
        let expected_der = load_cert("root-ca.der");
        let result = pem_to_der(&pem_data).expect("PEM to DER should succeed");
        assert_eq!(result, expected_der, "converted DER should match reference");
    }

    #[test]
    fn der_to_pem_conversion() {
        let der_data = load_cert("root-ca.der");
        let pem_str = der_to_pem(&der_data);
        assert!(
            pem_str.contains("BEGIN CERTIFICATE"),
            "should have PEM header"
        );
        assert!(
            pem_str.contains("END CERTIFICATE"),
            "should have PEM footer"
        );
    }

    #[test]
    fn pem_to_der_to_pem_roundtrip() {
        let original_pem = load_cert("server.pem");
        let der = pem_to_der(&original_pem).expect("PEM to DER should succeed");
        let pem_again = der_to_pem(&der);

        // The PEM might have different whitespace, so compare via DER
        let der_again = pem_to_der(pem_again.as_bytes()).expect("should parse regenerated PEM");
        assert_eq!(der, der_again, "roundtrip should preserve certificate");
    }

    #[test]
    fn der_to_pem_to_der_roundtrip() {
        let original_der = load_cert("server.der");
        let pem = der_to_pem(&original_der);
        let der_again = pem_to_der(pem.as_bytes()).expect("should parse generated PEM");
        assert_eq!(
            original_der, der_again,
            "roundtrip should preserve certificate"
        );
    }

    #[test]
    fn pem_to_der_invalid_input() {
        assert!(pem_to_der(b"not a pem").is_err());
    }
}

// =========================================================================
// 8. DISPLAY TESTS
// =========================================================================

mod display {
    use super::*;

    #[test]
    fn display_text_contains_subject() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("www.example.com"),
            "text output should contain subject CN"
        );
    }

    #[test]
    fn display_text_contains_issuer() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Test Intermediate CA"),
            "text output should contain issuer CN"
        );
    }

    #[test]
    fn display_text_contains_serial() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("1000") || text.contains("10:00"),
            "text output should contain serial number"
        );
    }

    #[test]
    fn display_text_contains_validity() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("2026") && text.contains("2101"),
            "text output should contain validity dates"
        );
    }

    #[test]
    fn display_text_contains_extensions() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Subject Alternative Name")
                || text.contains("SAN")
                || text.contains("subjectAltName"),
            "text output should mention SAN extension"
        );
    }

    #[test]
    fn display_text_contains_fingerprint() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Fingerprint") || text.contains("fingerprint"),
            "text output should contain fingerprint"
        );
    }

    #[test]
    fn display_text_all_includes_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, true);
        assert!(
            text.contains("Signature") || text.contains("signature"),
            "display_text with show_all should include signature"
        );
    }

    #[test]
    fn json_contains_expected_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let json_str = to_json(&cert).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();

        assert!(parsed.get("version").is_some(), "JSON should have version");
        assert!(parsed.get("serial").is_some(), "JSON should have serial");
        assert!(parsed.get("subject").is_some(), "JSON should have subject");
        assert!(parsed.get("issuer").is_some(), "JSON should have issuer");
        assert!(
            parsed.get("not_before").is_some(),
            "JSON should have not_before"
        );
        assert!(
            parsed.get("not_after").is_some(),
            "JSON should have not_after"
        );
        assert!(
            parsed.get("extensions").is_some(),
            "JSON should have extensions"
        );
    }
}

// =========================================================================
// 9. ALGORITHM-SPECIFIC TESTS
// =========================================================================

mod algorithms {
    use super::*;

    #[test]
    fn rsa_cert_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert!(cert.public_key.modulus.is_some());
        assert!(cert.public_key.curve.is_none());
    }

    #[test]
    fn ecdsa_p256_cert_fields() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-256")
                || cert.public_key.curve.as_deref() == Some("prime256v1"),
            "curve: {:?}",
            cert.public_key.curve
        );
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn ecdsa_p384_cert_fields() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-384")
                || cert.public_key.curve.as_deref() == Some("secp384r1"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ed25519_cert_fields() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn all_cert_types_produce_valid_fingerprints() {
        for name in &[
            "root-ca.pem",
            "server.pem",
            "client.pem",
            "ec-p256.pem",
            "ec-p384.pem",
            "ed25519.pem",
            "minimal.pem",
            "many-extensions.pem",
        ] {
            let data = load_cert(name);
            let cert = parse_cert(&data).unwrap();
            let fp = cert.fingerprint(DigestAlgorithm::Sha256);
            // SHA-256 = 32 bytes = 32*3-1 = 95 chars
            assert_eq!(
                fp.len(),
                95,
                "SHA-256 fingerprint for {} has wrong length: {} ({})",
                name,
                fp.len(),
                fp
            );
        }
    }
}

// =========================================================================
// 10. DEGENERATE / MALFORMED INPUT TESTS
// =========================================================================
//
// These test vectors exercise edge cases and error-handling paths in the
// parser.  Each test asserts that the library returns an error (or, where
// noted, succeeds gracefully) without panicking or hanging.

mod degenerate {
    use super::*;

    /// Helper: build a path under tests/certs/degenerate/
    fn degen_path(name: &str) -> std::path::PathBuf {
        let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        p.pop(); // up from xcert-lib to workspace root
        p.push("tests");
        p.push("certs");
        p.push("degenerate");
        p.push(name);
        p
    }

    fn load_degen(name: &str) -> Vec<u8> {
        std::fs::read(degen_path(name))
            .unwrap_or_else(|e| panic!("Failed to read degenerate test file '{}': {}", name, e))
    }

    // -----------------------------------------------------------------
    // 1. empty.der -- 0-byte file
    // -----------------------------------------------------------------
    #[test]
    fn empty_file_returns_error() {
        let data = load_degen("empty.der");
        assert!(data.is_empty());
        let result = parse_cert(&data);
        assert!(result.is_err(), "empty input must return an error");
    }

    #[test]
    fn empty_file_der_returns_error() {
        let data = load_degen("empty.der");
        let result = parse_der(&data);
        assert!(result.is_err(), "empty DER input must return an error");
    }

    // -----------------------------------------------------------------
    // 2. one-byte.der -- single SEQUENCE tag, no length or body
    // -----------------------------------------------------------------
    #[test]
    fn one_byte_returns_error() {
        let data = load_degen("one-byte.der");
        assert_eq!(data.len(), 1);
        assert_eq!(data[0], 0x30, "should be a SEQUENCE tag");
        let result = parse_der(&data);
        assert!(result.is_err(), "single byte must return an error");
    }

    // -----------------------------------------------------------------
    // 3. truncated-header.der -- first 10 bytes of a valid DER cert
    // -----------------------------------------------------------------
    #[test]
    fn truncated_header_returns_error() {
        let data = load_degen("truncated-header.der");
        assert_eq!(data.len(), 10);
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "truncated header (10 bytes) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 4. truncated-body.der -- first half of a valid DER cert
    // -----------------------------------------------------------------
    #[test]
    fn truncated_body_returns_error() {
        let data = load_degen("truncated-body.der");
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "truncated body (half cert) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 5. random-bytes.der -- 1024 random bytes
    // -----------------------------------------------------------------
    #[test]
    fn random_bytes_returns_error() {
        let data = load_degen("random-bytes.der");
        assert_eq!(data.len(), 1024);
        let result = parse_der(&data);
        assert!(result.is_err(), "random bytes must return an error");
    }

    // -----------------------------------------------------------------
    // 6. wrong-pem-label.pem -- valid base64 but "BEGIN RSA PRIVATE KEY"
    // -----------------------------------------------------------------
    #[test]
    fn wrong_pem_label_returns_error() {
        let data = load_degen("wrong-pem-label.pem");
        let result = parse_pem(&data);
        assert!(
            result.is_err(),
            "PEM with RSA PRIVATE KEY label must return an error"
        );
    }

    #[test]
    fn wrong_pem_label_auto_detect_returns_error() {
        let data = load_degen("wrong-pem-label.pem");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "wrong PEM label via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 7. corrupt-base64.pem -- PEM headers with invalid base64 body
    // -----------------------------------------------------------------
    #[test]
    fn corrupt_base64_returns_error() {
        let data = load_degen("corrupt-base64.pem");
        let result = parse_pem(&data);
        assert!(result.is_err(), "corrupt base64 PEM must return an error");
    }

    #[test]
    fn corrupt_base64_auto_detect_returns_error() {
        let data = load_degen("corrupt-base64.pem");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "corrupt base64 via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 8. null-bytes.der -- 1024 null bytes
    // -----------------------------------------------------------------
    #[test]
    fn null_bytes_returns_error() {
        let data = load_degen("null-bytes.der");
        assert_eq!(data.len(), 1024);
        assert!(data.iter().all(|&b| b == 0));
        let result = parse_der(&data);
        assert!(result.is_err(), "1024 null bytes must return an error");
    }

    // -----------------------------------------------------------------
    // 9. huge-length.der -- SEQUENCE claiming 2GB, only 100 bytes of data
    // -----------------------------------------------------------------
    #[test]
    fn huge_length_returns_error() {
        let data = load_degen("huge-length.der");
        assert_eq!(data.len(), 106, "header(6) + filler(100)");
        // Must not hang or allocate 2GB; must return an error promptly
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "DER with huge claimed length must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 10. nested-sequence.der -- 100 levels of nested SEQUENCE
    // -----------------------------------------------------------------
    #[test]
    fn nested_sequence_returns_error() {
        let data = load_degen("nested-sequence.der");
        // This is valid DER structurally (nested SEQUENCEs) but is
        // not a valid certificate.  The parser must return an error
        // without stack-overflowing.
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "deeply nested SEQUENCEs (not a cert) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 11. negative-serial.der -- certificate with tweaked negative serial
    // -----------------------------------------------------------------
    #[test]
    fn negative_serial_parses_or_errors_gracefully() {
        let data = load_degen("negative-serial.der");
        // A real-world parser might accept or reject a negative serial.
        // The important thing is it must not panic.
        let result = parse_der(&data);
        // If it succeeds, the serial should be non-empty.
        // If it fails, the error must be an Err, not a panic.
        match result {
            Ok(cert) => {
                let serial = cert.serial_hex();
                assert!(!serial.is_empty(), "if parsed, serial should be non-empty");
            }
            Err(_) => {
                // Returning an error is also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // 12. trailing-garbage.pem -- valid PEM cert + 1KB garbage appended
    // -----------------------------------------------------------------
    #[test]
    fn trailing_garbage_parses_first_cert() {
        let data = load_degen("trailing-garbage.pem");
        // The PEM parser should extract the first valid certificate
        // and ignore trailing garbage after the END marker.
        let result = parse_pem(&data);
        // Depending on the PEM parser, this may succeed (ignoring
        // trailing bytes) or fail.  Either is acceptable; no panic.
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
                assert!(cert.subject_string().contains("Test Root CA"));
            }
            Err(_) => {
                // Returning an error for trailing garbage is also fine
            }
        }
    }

    #[test]
    fn trailing_garbage_auto_detect() {
        let data = load_degen("trailing-garbage.pem");
        let result = parse_cert(&data);
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
            }
            Err(_) => {
                // Also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // 13. multiple-pem.pem -- cert + private key block + cert
    // -----------------------------------------------------------------
    #[test]
    fn multiple_pem_parses_first_cert() {
        let data = load_degen("multiple-pem.pem");
        // parse_pem should take the first PEM block it finds.
        // If the first block is a CERTIFICATE, it should succeed.
        let result = parse_pem(&data);
        match result {
            Ok(cert) => {
                // First block is root-ca.pem
                assert_eq!(cert.version, 3);
                assert!(
                    cert.subject_string().contains("Test Root CA"),
                    "should parse the first cert (root CA)"
                );
            }
            Err(e) => {
                // If the parser rejects mixed PEM, that is acceptable
                // as long as it does not panic
                let _ = e;
            }
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken inputs should panic parse_cert
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_input() {
        let files = [
            "empty.der",
            "one-byte.der",
            "truncated-header.der",
            "truncated-body.der",
            "random-bytes.der",
            "wrong-pem-label.pem",
            "corrupt-base64.pem",
            "null-bytes.der",
            "huge-length.der",
            "nested-sequence.der",
            "negative-serial.der",
            "trailing-garbage.pem",
            "multiple-pem.pem",
        ];
        for name in &files {
            let data = load_degen(name);
            // Must not panic.  We use catch_unwind to turn panics
            // into failures with a clear message.
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_cert(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_cert panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken DER inputs should panic
    // parse_der
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_der_input() {
        let files = [
            "empty.der",
            "one-byte.der",
            "truncated-header.der",
            "truncated-body.der",
            "random-bytes.der",
            "null-bytes.der",
            "huge-length.der",
            "nested-sequence.der",
            "negative-serial.der",
        ];
        for name in &files {
            let data = load_degen(name);
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_der(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_der panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken PEM inputs should panic
    // parse_pem
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_pem_input() {
        let files = [
            "wrong-pem-label.pem",
            "corrupt-base64.pem",
            "trailing-garbage.pem",
            "multiple-pem.pem",
        ];
        for name in &files {
            let data = load_degen(name);
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_pem(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_pem panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: pem_to_der should also handle broken PEM inputs
    // -----------------------------------------------------------------
    #[test]
    fn pem_to_der_rejects_corrupt_base64() {
        let data = load_degen("corrupt-base64.pem");
        let result = pem_to_der(&data);
        assert!(result.is_err(), "pem_to_der must reject corrupt base64");
    }

    #[test]
    fn pem_to_der_rejects_wrong_label() {
        let data = load_degen("wrong-pem-label.pem");
        // pem_to_der extracts bytes regardless of label (it uses
        // x509_parser::pem which may or may not check).  Either
        // success or error is fine; must not panic.
        let _ = pem_to_der(&data);
    }
}

// =========================================================================
// 10. CERTIFICATE CHAIN VERIFICATION TESTS
// =========================================================================

mod verification {
    use super::*;

    fn real_cert_path(name: &str) -> std::path::PathBuf {
        let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        p.pop();
        p.push("tests");
        p.push("certs");
        p.push("real");
        p.push(name);
        p
    }

    fn load_real_cert(name: &str) -> Vec<u8> {
        std::fs::read(real_cert_path(name))
            .unwrap_or_else(|e| panic!("Failed to read real cert '{}': {}", name, e))
    }

    fn test_trust_store() -> TrustStore {
        let root_pem = load_real_cert("test-root-ca.pem");
        TrustStore::from_pem(&root_pem).expect("failed to create trust store from test root CA")
    }

    fn ec_trust_store() -> TrustStore {
        let root_pem = load_real_cert("test-ec-root-ca.pem");
        TrustStore::from_pem(&root_pem).expect("failed to create trust store from EC root CA")
    }

    // -----------------------------------------------------------------------
    // PEM chain parsing
    // -----------------------------------------------------------------------

    #[test]
    fn parse_pem_chain_single_cert() {
        let data = load_real_cert("test-root-ca.pem");
        let chain = parse_pem_chain(&data).expect("failed to parse single cert");
        assert_eq!(chain.len(), 1);
    }

    #[test]
    fn parse_pem_chain_full_chain() {
        let data = load_real_cert("test-fullchain.pem");
        let chain = parse_pem_chain(&data).expect("failed to parse full chain");
        assert_eq!(
            chain.len(),
            3,
            "full chain should have 3 certs: leaf + intermediate + root"
        );
    }

    #[test]
    fn parse_pem_chain_two_certs() {
        // server.pem + intermediate-ca.pem
        let server = load_real_cert("test-server.pem");
        let intermediate = load_real_cert("test-intermediate-ca.pem");
        let mut combined = server;
        combined.extend_from_slice(&intermediate);
        let chain = parse_pem_chain(&combined).expect("failed to parse two-cert chain");
        assert_eq!(chain.len(), 2);
    }

    #[test]
    fn parse_pem_chain_empty_input() {
        let result = parse_pem_chain(b"");
        assert!(result.is_err(), "empty input should fail");
    }

    #[test]
    fn parse_pem_chain_no_certs() {
        let result = parse_pem_chain(b"not a cert");
        assert!(result.is_err(), "non-cert input should fail");
    }

    // -----------------------------------------------------------------------
    // Trust store
    // -----------------------------------------------------------------------

    #[test]
    fn trust_store_new_is_empty() {
        let store = TrustStore::new();
        assert!(store.is_empty());
        assert_eq!(store.len(), 0);
    }

    #[test]
    fn trust_store_from_pem_single_cert() {
        let store = test_trust_store();
        assert_eq!(store.len(), 1);
        assert!(!store.is_empty());
    }

    #[test]
    fn trust_store_from_pem_bundle() {
        let data = load_real_cert("test-fullchain.pem");
        let store = TrustStore::from_pem(&data).expect("failed to load bundle");
        assert_eq!(store.len(), 3, "bundle with 3 certs should load 3 entries");
    }

    #[test]
    fn trust_store_contains_added_cert() {
        let root_pem = load_real_cert("test-root-ca.pem");
        let chain = parse_pem_chain(&root_pem).expect("parse root");
        let store = test_trust_store();
        assert!(
            store.contains(&chain[0]),
            "trust store should contain the root cert"
        );
    }

    #[test]
    fn trust_store_does_not_contain_unknown_cert() {
        let server_pem = load_real_cert("test-server.pem");
        let chain = parse_pem_chain(&server_pem).expect("parse server");
        let store = test_trust_store();
        assert!(
            !store.contains(&chain[0]),
            "trust store should not contain server cert"
        );
    }

    // -----------------------------------------------------------------------
    // Chain verification - valid chains
    // -----------------------------------------------------------------------

    #[test]
    fn verify_valid_full_chain() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "valid full chain should verify: {:?}",
            result.errors
        );
        assert_eq!(result.chain.len(), 3);
        assert_eq!(result.errors.len(), 0);
    }

    #[test]
    fn verify_chain_without_root_uses_trust_store() {
        // Chain is leaf + intermediate; root should come from trust store
        let server = load_real_cert("test-server.pem");
        let intermediate = load_real_cert("test-intermediate-ca.pem");
        let mut chain_pem = server;
        chain_pem.extend_from_slice(&intermediate);

        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "chain without root should verify using trust store: {:?}",
            result.errors
        );
        // Chain info should include root from trust store
        assert_eq!(
            result.chain.len(),
            3,
            "chain should be extended with root from trust store"
        );
    }

    #[test]
    fn verify_valid_chain_with_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("www.example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "hostname www.example.com should match: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_valid_chain_with_san_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "hostname example.com should match SAN: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_valid_chain_with_wildcard_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("sub.example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "wildcard *.example.com should match sub.example.com: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_ec_chain() {
        let chain_pem = load_real_cert("test-ec-fullchain.pem");
        let store = ec_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "EC chain should verify: {:?}",
            result.errors
        );
        assert_eq!(result.chain.len(), 2);
    }

    #[test]
    fn verify_ec_chain_with_hostname() {
        let chain_pem = load_real_cert("test-ec-fullchain.pem");
        let store = ec_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("ec.example.com"))
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "EC cert hostname should match: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_self_signed_root_in_trust_store() {
        let root_pem = load_real_cert("test-root-ca.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&root_pem, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "self-signed root in trust store should verify: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // Chain verification - invalid chains
    // -----------------------------------------------------------------------

    #[test]
    fn verify_wrong_chain_fails_signature() {
        let chain_pem = load_real_cert("test-wrong-chain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error (just return invalid)");
        assert!(!result.is_valid, "wrong chain should not verify");
        // Path building may return "signature verification failed" (if it
        // tries the chain as given) or "unable to find trusted root" (if the
        // DFS cannot build a chain to any trust anchor). Either is correct.
        assert!(
            result.errors.iter().any(|e| {
                e.contains("signature verification failed")
                    || e.contains("unable to find trusted root")
            }),
            "should report chain error: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_untrusted_root_fails() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        // Use a different root as trust store - the chain's root won't be in it
        let store = ec_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        assert!(!result.is_valid, "chain with untrusted root should fail");
        // Path building may return "not in the trust store" (if it uses the
        // chain as given) or "unable to find trusted root" (if the DFS cannot
        // build a chain to any trust anchor). Either is correct.
        assert!(
            result.errors.iter().any(|e| {
                e.contains("not in the trust store") || e.contains("unable to find trusted root")
            }),
            "should report untrusted root: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_wrong_hostname_fails() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("wrong.example.org"))
            .expect("verification should not error");
        assert!(!result.is_valid, "wrong hostname should fail");
        assert!(
            result
                .errors
                .iter()
                .any(|e| e.contains("hostname") && e.contains("wrong.example.org")),
            "should report hostname mismatch: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_deep_wildcard_does_not_match() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        // *.example.com should NOT match deep.sub.example.com
        let result = verify_pem_chain(&chain_pem, &store, Some("deep.sub.example.com"))
            .expect("verification should not error");
        assert!(!result.is_valid, "deep subdomain should not match wildcard");
    }

    #[test]
    fn verify_self_signed_not_in_trust_store_fails() {
        let root_pem = load_real_cert("test-root-ca.pem");
        // Use EC trust store (doesn't contain RSA root)
        let store = ec_trust_store();
        let result =
            verify_pem_chain(&root_pem, &store, None).expect("verification should not error");
        assert!(
            !result.is_valid,
            "self-signed cert not in trust store should fail"
        );
    }

    #[test]
    fn verify_empty_chain_errors() {
        let store = test_trust_store();
        let result = verify_chain(&[], &store, None);
        assert!(result.is_err(), "empty chain should be an error");
    }

    #[test]
    fn verify_chain_missing_intermediate() {
        // Just the leaf, no intermediate - root can't verify it directly
        let server_pem = load_real_cert("test-server.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&server_pem, &store, None).expect("verification should not error");
        assert!(
            !result.is_valid,
            "leaf without intermediate should fail verification"
        );
    }

    // -----------------------------------------------------------------------
    // Chain verification with DER input
    // -----------------------------------------------------------------------

    #[test]
    fn verify_chain_from_der() {
        let fullchain_pem = load_real_cert("test-fullchain.pem");
        let chain_der = parse_pem_chain(&fullchain_pem).expect("parse PEM chain");
        let store = test_trust_store();
        let result = verify_chain(&chain_der, &store, None).expect("verification should not error");
        assert!(
            result.is_valid,
            "DER chain should verify: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // Verification result structure
    // -----------------------------------------------------------------------

    #[test]
    fn verification_result_chain_depth_ordering() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");

        for (i, cert) in result.chain.iter().enumerate() {
            assert_eq!(cert.depth, i, "chain depth should be sequential");
        }
        // Leaf at depth 0
        assert!(result.chain[0].subject.contains("www.example.com"));
        // Root at last depth
        let last = &result.chain[result.chain.len() - 1];
        assert!(last.subject.contains("Test Root CA"));
    }

    #[test]
    fn verification_result_serializes_to_json() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        let json = serde_json::to_string(&result).expect("should serialize to JSON");
        assert!(json.contains("is_valid"));
        assert!(json.contains("chain"));
    }

    // -----------------------------------------------------------------------
    // System trust store with real CA certificates
    // -----------------------------------------------------------------------

    #[test]
    fn system_trust_store_contains_real_cas() {
        let store = TrustStore::system().expect("system trust store should load");
        // System store should have a reasonable number of CAs
        assert!(
            store.len() >= 50,
            "system store has only {} CAs",
            store.len()
        );
    }

    #[test]
    fn system_trust_store_real_ca_certs_are_parseable() {
        // Load individual real CA certs extracted from system store and verify they parse
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let cert = parse_cert(&data).unwrap_or_else(|e| {
                panic!("Real CA cert {} should parse: {}", name, e);
            });
            // Real CA certs should have CA=TRUE in basic constraints
            let is_ca = cert.extensions.iter().any(|ext| {
                matches!(
                    &ext.value,
                    ExtensionValue::BasicConstraints { ca: true, .. }
                )
            });
            assert!(is_ca, "Real CA cert {} should have CA:TRUE", name);
        }
    }

    #[test]
    fn system_ca_certs_are_self_signed() {
        // Root CA certs should be self-signed (issuer == subject)
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let cert = parse_cert(&data).unwrap_or_else(|e| {
                panic!("Real CA cert {} should parse: {}", name, e);
            });
            assert_eq!(
                cert.subject.to_oneline(),
                cert.issuer.to_oneline(),
                "Root CA {} should be self-signed (subject == issuer)",
                name
            );
        }
    }

    #[test]
    fn system_ca_certs_verify_as_self_signed() {
        // Root CAs should verify their own signatures
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let chain_der = parse_pem_chain(&data).expect("parse CA cert");
            let store = TrustStore::from_pem(&data).expect("create store from CA cert");
            let result =
                verify_chain(&chain_der, &store, None).expect("verification should not error");
            assert!(
                result.is_valid,
                "Real CA cert {} should verify as self-signed: {:?}",
                name, result.errors
            );
        }
    }

    #[test]
    fn verify_chain_with_system_trust_store_and_test_chain_fails() {
        // Our test chain uses a custom root CA not in the system store
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = TrustStore::system().expect("system trust store should load");
        let result =
            verify_pem_chain(&chain_pem, &store, None).expect("verification should not error");
        // Our test root is NOT in the system store, so this should fail
        assert!(
            !result.is_valid,
            "test chain should not verify against system store (custom root CA)"
        );
    }
}

// ===========================================================================
// Cross-compatibility tests using public test vectors
// ===========================================================================
//
// Test certificates sourced from:
//   - x509-parser (MIT/Apache-2.0): https://github.com/rusticata/x509-parser/tree/master/assets
//   - OpenSSL (Apache-2.0): https://github.com/openssl/openssl/tree/master/test/certs
//   - pyca/cryptography (Apache-2.0/BSD): https://github.com/pyca/cryptography
//
// Reference values extracted with `openssl x509` for cross-implementation verification.

fn load_external(name: &str) -> Vec<u8> {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop();
    p.push("tests");
    p.push("certs");
    p.push("external");
    p.push(name);
    std::fs::read(&p)
        .unwrap_or_else(|e| panic!("Failed to read external test cert '{}': {}", name, e))
}

/// Helper: parse an external cert from PEM.
fn parse_external_pem(name: &str) -> CertificateInfo {
    let data = load_external(name);
    parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse '{}': {}", name, e))
}

/// Helper: parse an external cert from DER.
fn parse_external_der(name: &str) -> CertificateInfo {
    let data = load_external(name);
    parse_der(&data).unwrap_or_else(|e| panic!("Failed to parse '{}': {}", name, e))
}

mod cross_compat_openssl {
    //! Tests against OpenSSL test suite certificates.
    use super::*;

    #[test]
    fn ossl_rsa_root_ca() {
        let cert = parse_external_pem("ossl-root-cert.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = Root CA"));
        assert!(cert.issuer_string().contains("CN = Root CA"));
        assert_eq!(cert.serial, "01");
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "BB:84:C7:81:92:4C:01:36:5E:65:AE:27:CE:26:DF:D5:D4:B8:F2:FD:57:60:CD:27:D3:0F:E7:8E:5A:B7:3F:1A"
        );
    }

    #[test]
    fn ossl_rsa_root_pubkey_pem() {
        let cert = parse_external_pem("ossl-root-cert.pem");
        let pem = cert.public_key_pem();
        assert!(pem.starts_with("-----BEGIN PUBLIC KEY-----"));
        assert!(pem.contains("MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBC"));
    }

    #[test]
    fn ossl_ecdsa_p256() {
        let cert = parse_external_pem("ossl-server-ecdsa-cert.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = Server ECDSA cert"));
        assert!(cert.issuer_string().contains("CN = Root CA"));
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(cert.public_key.key_size, Some(256));
        assert_eq!(cert.public_key.curve.as_deref(), Some("P-256"));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "E7:01:D8:30:25:6E:1B:E8:B2:0A:85:46:56:E6:C4:7A:38:37:BB:4E:59:B7:1D:8E:83:63:3B:15:EC:61:1D:3B"
        );
    }

    #[test]
    fn ossl_ecdsa_p256_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("ossl-server-ecdsa-cert.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4js03ETjze0nIgpPoo5AzlmV+uKC
HXYERwfGfOm52BUdgDhovkPkm6VgYXMvQtDlDnkakK5vVXaP4CHIEwo9Cg==
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn ossl_ed25519() {
        let cert = parse_external_pem("ossl-root-ed25519.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = IETF Test Demo"));
        assert!(cert.issuer_string().contains("CN = IETF Test Demo"));
        assert_eq!(cert.serial, "84:F1:08:3D:1C:E3:2D:95");
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert_eq!(cert.public_key.key_size, Some(256));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "A5:8E:62:33:C6:61:0A:1F:B1:DE:35:EE:33:AD:57:A2:50:D1:FE:2B:E7:62:E1:41:50:E6:B9:3A:E2:25:80:A3"
        );
    }

    #[test]
    fn ossl_ed25519_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("ossl-root-ed25519.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn ossl_ed448() {
        let cert = parse_external_pem("ossl-root-ed448-cert.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = Root Ed448"));
        assert_eq!(cert.public_key.algorithm, "Ed448");
        assert_eq!(cert.public_key.key_size, Some(448));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "6C:11:DC:C0:EE:96:65:07:17:D0:E9:16:08:D8:CF:BC:7A:26:C2:CF:57:CC:41:5F:B7:5A:94:9F:F1:20:AC:A9"
        );
    }

    #[test]
    fn ossl_ed448_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("ossl-root-ed448-cert.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MEMwBQYDK2VxAzoAbbhuwNA/rdlgdLSyTJ6WaCVNO1gzccKiKW6pCADMMcMBCNiQ
qWSt4EIbHpqDc+eWoiKbG6t7tjUA
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn ossl_many_names_parses_without_panic() {
        let cert = parse_external_pem("ossl-many-names1.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = t0.test"));
        // This cert has 513 emailAddress attributes in the subject
        let email_count = cert
            .subject
            .components
            .iter()
            .filter(|(k, _)| k == "emailAddress")
            .count();
        assert!(
            email_count > 100,
            "expected many emailAddress components, got {}",
            email_count
        );
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "CC:14:A3:C9:50:39:2F:32:49:A3:C6:7A:FA:66:8F:29:70:B4:45:03:6B:7A:6E:11:A6:3F:BF:C8:B6:3D:D2:97"
        );
    }
}

mod cross_compat_pyca {
    //! Tests against pyca/cryptography test vectors.
    use super::*;

    #[test]
    fn pyca_ecdsa_p384_root() {
        let cert = parse_external_pem("pyca-ecdsa-root.pem");
        assert_eq!(cert.version, 3);
        assert!(cert
            .subject_string()
            .contains("CN = DigiCert Global Root G3"));
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(cert.public_key.key_size, Some(384));
        assert_eq!(cert.public_key.curve.as_deref(), Some("P-384"));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "31:AD:66:48:F8:10:41:38:C7:38:F3:9E:A4:32:01:33:39:3E:3A:18:CC:02:29:6E:F9:7C:2A:C9:EF:67:31:D0"
        );
    }

    #[test]
    fn pyca_ecdsa_p384_pubkey_pem_matches_openssl() {
        let cert = parse_external_pem("pyca-ecdsa-root.pem");
        let expected = "\
-----BEGIN PUBLIC KEY-----
MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOre
xpu80JX28MzQC7phW1FGfp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0D
Q+4QE2xy3q6Ip6FrtUPOZ9wj/wMco+I+
-----END PUBLIC KEY-----\n";
        assert_eq!(cert.public_key_pem(), expected);
    }

    #[test]
    fn pyca_letsencrypt_x3() {
        let cert = parse_external_pem("pyca-letsencrypt-x3.pem");
        assert_eq!(cert.version, 3);
        assert!(cert
            .subject_string()
            .contains("CN = Let's Encrypt Authority X3"));
        assert!(cert.issuer_string().contains("CN = DST Root CA X3"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "25:84:7D:66:8E:B4:F0:4F:DD:40:B1:2B:6B:07:40:C5:67:DA:7D:02:43:08:EB:6C:2C:96:FE:41:D9:DE:21:8D"
        );
    }

    #[test]
    fn pyca_v1_cert() {
        let cert = parse_external_pem("pyca-v1.pem");
        assert_eq!(cert.version, 1);
        assert!(cert.subject_string().contains("CN = SSLeay/rsa test cert"));
        assert!(cert.issuer_string().contains("CN = SSLeay/rsa test CA"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(512));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "5B:7C:4E:9F:7E:70:16:2F:CC:12:A8:D2:41:6D:AE:35:12:73:97:9F:0E:D0:C9:7D:0F:F1:26:FD:73:A7:EE:66"
        );
        // v1 certs have no extensions
        assert!(cert.extensions.is_empty());
    }

    #[test]
    fn pyca_wildcard_san() {
        let cert = parse_external_pem("pyca-wildcard-san.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = *.langui.sh"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(4096));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "68:98:6E:4D:DA:05:76:BF:E3:61:A7:90:EE:A9:E0:16:15:F6:88:30:4C:17:69:22:1C:73:7E:2B:FD:39:2E:CE"
        );
        // Check wildcard SAN entries
        let san: Vec<_> = cert.san_entries();
        assert!(!san.is_empty());
        let dns_names: Vec<_> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Dns(n) => Some(n.as_str()),
                _ => None,
            })
            .collect();
        assert!(dns_names.contains(&"*.langui.sh"));
    }

    #[test]
    fn pyca_utf8_dnsname() {
        let cert = parse_external_pem("pyca-utf8-dnsname.pem");
        assert_eq!(cert.version, 3);
        // Subject contains UTF-8 characters
        assert!(cert.subject_string().contains("partner.biztositas.hu"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "FC:3E:3A:A4:21:D3:75:AB:E0:1E:6B:68:13:2C:C0:96:EE:66:24:19:EA:80:84:CC:8E:FC:4A:94:99:57:D6:8E"
        );
    }

    #[test]
    fn pyca_dsa_selfsigned() {
        let cert = parse_external_pem("pyca-dsa-selfsigned.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = PyCA DSA CA"));
        // DSA is not one of our named algorithms so it falls back to OID
        assert!(
            cert.public_key.algorithm == "DSA"
                || cert.public_key.algorithm.contains("1.2.840.10040.4.1"),
            "expected DSA or DSA OID, got '{}'",
            cert.public_key.algorithm
        );
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "0A:A0:FD:DB:5B:87:8E:EE:B5:92:FB:7F:12:2C:A0:05:BC:3B:63:A3:C4:D8:A7:E9:6B:89:CA:B1:FB:5E:70:7F"
        );
    }
}

mod cross_compat_x509_parser {
    //! Tests against x509-parser's own test assets.
    use super::*;

    #[test]
    fn x509p_certificate_pem() {
        let cert = parse_external_pem("x509p-certificate.pem");
        assert_eq!(cert.version, 3);
        assert!(cert.subject_string().contains("CN = lists.for-our.info"));
        assert!(cert
            .issuer_string()
            .contains("CN = Let's Encrypt Authority X3"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "8F:A4:CB:4E:93:8B:5A:85:5F:B1:49:7F:A2:88:AC:55:72:3E:01:09:D0:51:8B:50:54:81:34:8D:EC:0D:E4:71"
        );
    }

    #[test]
    fn x509p_igc_a_french_gov_root() {
        let cert = parse_external_pem("x509p-IGC_A.pem");
        assert_eq!(cert.version, 3);
        // French government root CA with rich DN
        assert!(cert.subject_string().contains("CN = IGC/A"));
        assert!(cert.subject_string().contains("C = FR"));
        assert!(cert.subject_string().contains("O = PM/SGDN"));
        assert!(cert.subject_string().contains("OU = DCSSI"));
        // Self-signed
        assert_eq!(cert.subject_string(), cert.issuer_string());
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "B9:BE:A7:86:0A:96:2E:A3:61:1D:AB:97:AB:6D:A3:E2:1C:10:68:B9:7D:55:57:5E:D0:E1:12:79:C1:1C:89:32"
        );
    }

    #[test]
    fn x509p_no_extensions() {
        let cert = parse_external_pem("x509p-no_extensions.pem");
        assert!(cert.subject_string().contains("CN = benno"));
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(cert.public_key.key_size, Some(384));
        assert!(cert.extensions.is_empty());
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "39:F4:1F:F9:38:5A:90:DF:31:A9:0F:C6:C0:C6:86:CF:23:43:DE:A2:F1:8C:D0:58:33:9A:0D:00:A0:7A:51:CB"
        );
    }

    #[test]
    fn x509p_ed25519_der() {
        let cert = parse_external_der("x509p-ed25519.der");
        assert!(cert.subject_string().contains("CN = www.example.com"));
        assert!(cert.subject_string().contains("C = DE"));
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert_eq!(cert.public_key.key_size, Some(256));
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "D3:86:93:B6:76:F3:B8:0B:18:3E:7A:B6:1D:14:18:2A:9D:20:7C:13:1A:35:ED:67:69:6C:F8:95:59:72:55:1D"
        );
    }

    #[test]
    fn x509p_v1_cert() {
        let cert = parse_external_der("x509p-v1.der");
        assert_eq!(cert.version, 1);
        assert!(cert.subject_string().contains("CN = marquee"));
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert!(cert.extensions.is_empty());
        assert_eq!(
            cert.fingerprint(DigestAlgorithm::Sha256),
            "3D:6D:A6:82:D3:30:93:D8:5A:A6:32:84:6B:A9:FA:BF:31:FE:90:ED:C0:91:A2:7F:D7:F6:2E:51:4F:85:8C:57"
        );
    }
}

mod cross_compat_conversion {
    //! Roundtrip conversion tests on external certificates.
    use super::*;

    #[test]
    fn ossl_rsa_pem_to_der_roundtrip() {
        let pem_data = load_external("ossl-root-cert.pem");
        let der_bytes = pem_to_der(&pem_data).unwrap();
        let pem_string = der_to_pem(&der_bytes);
        let re_der = pem_to_der(pem_string.as_bytes()).unwrap();
        assert_eq!(der_bytes, re_der);
        // Fingerprints must match
        let cert1 = parse_pem(&pem_data).unwrap();
        let cert2 = parse_der(&der_bytes).unwrap();
        assert_eq!(
            cert1.fingerprint(DigestAlgorithm::Sha256),
            cert2.fingerprint(DigestAlgorithm::Sha256),
        );
    }
}

mod cross_compat_auto_detect {
    //! Verify that auto-detection (parse_cert) works for all external formats.
    use super::*;

    #[test]
    fn auto_detect_all_pem_files() {
        let pem_files = [
            "ossl-root-cert.pem",
            "ossl-server-ecdsa-cert.pem",
            "ossl-root-ed25519.pem",
            "ossl-root-ed448-cert.pem",
            "ossl-many-names1.pem",
            "pyca-ecdsa-root.pem",
            "pyca-v1.pem",
            "pyca-letsencrypt-x3.pem",
            "pyca-wildcard-san.pem",
            "pyca-utf8-dnsname.pem",
            "pyca-dsa-selfsigned.pem",
            "x509p-certificate.pem",
            "x509p-IGC_A.pem",
            "x509p-no_extensions.pem",
        ];
        for name in &pem_files {
            let data = load_external(name);
            let cert = parse_cert(&data)
                .unwrap_or_else(|e| panic!("parse_cert failed on PEM file '{}': {}", name, e));
            assert!(
                cert.version >= 1 && cert.version <= 3,
                "bad version in {}",
                name
            );
            assert!(!cert.serial.is_empty(), "empty serial in {}", name);
            assert!(
                !cert.subject_string().is_empty(),
                "empty subject in {}",
                name
            );
        }
    }

    #[test]
    fn auto_detect_all_der_files() {
        let der_files = [
            "x509p-certificate.der",
            "x509p-IGC_A.der",
            "x509p-no_extensions.der",
            "x509p-ed25519.der",
            "x509p-v1.der",
        ];
        for name in &der_files {
            let data = load_external(name);
            let cert = parse_cert(&data)
                .unwrap_or_else(|e| panic!("parse_cert failed on DER file '{}': {}", name, e));
            assert!(
                cert.version >= 1 && cert.version <= 3,
                "bad version in {}",
                name
            );
            assert!(!cert.serial.is_empty(), "empty serial in {}", name);
        }
    }

    #[test]
    fn display_and_json_work_for_all_external_certs() {
        let all_pem = [
            "ossl-root-cert.pem",
            "ossl-server-ecdsa-cert.pem",
            "ossl-root-ed25519.pem",
            "ossl-root-ed448-cert.pem",
            "pyca-ecdsa-root.pem",
            "pyca-v1.pem",
            "pyca-letsencrypt-x3.pem",
            "pyca-dsa-selfsigned.pem",
            "x509p-certificate.pem",
            "x509p-IGC_A.pem",
            "x509p-no_extensions.pem",
        ];
        for name in &all_pem {
            let data = load_external(name);
            let cert = parse_cert(&data).unwrap();
            let text = display_text(&cert, true);
            assert!(
                text.contains("Certificate:"),
                "display_text broken for {}",
                name
            );
            let json =
                to_json(&cert).unwrap_or_else(|e| panic!("to_json failed for '{}': {}", name, e));
            assert!(
                json.contains("version"),
                "JSON missing version for {}",
                name
            );
        }
    }
}

// =========================================================================
// REFERENCE TEST VECTORS
// =========================================================================
//
// Compare library output against OpenSSL-generated reference files in
// tests/certs/reference/ for regression detection.

mod reference_vectors {
    use super::*;

    /// Normalize an OpenSSL serial like "1000" or "01" to our colon-separated
    /// format. OpenSSL outputs uppercase hex without colons; our library uses
    /// colon-separated pairs.
    fn normalize_serial(openssl_serial: &str) -> String {
        let hex = openssl_serial.trim().to_ascii_uppercase();
        // Pad to even length
        let hex = if hex.len() % 2 != 0 {
            format!("0{}", hex)
        } else {
            hex
        };
        hex.as_bytes()
            .chunks(2)
            .map(|c| std::str::from_utf8(c).unwrap_or(""))
            .collect::<Vec<_>>()
            .join(":")
    }

    /// Parse OpenSSL fingerprint like "sha256 Fingerprint=AA:BB:CC:..."
    /// Returns just the "AA:BB:CC:..." part.
    fn parse_fingerprint(line: &str) -> &str {
        line.split('=').nth(1).unwrap_or(line).trim()
    }

    /// Parse OpenSSL subject/issuer like "subject=C = US, ST = California, ..."
    /// into a list of (key, value) pairs. OpenSSL uses spaces around `=`.
    fn parse_dn_components(line: &str) -> Vec<(String, String)> {
        // Strip "subject=" or "issuer=" prefix
        let dn_str = line.split_once('=').map(|(_, v)| v).unwrap_or(line);
        let mut components = Vec::new();
        for part in dn_str.split(", ") {
            if let Some((key, val)) = part.split_once(" = ") {
                components.push((key.trim().to_string(), val.trim().to_string()));
            }
        }
        components
    }

    /// Test data: (cert_file, reference_prefix)
    const CERTS: &[(&str, &str)] = &[
        ("root-ca.pem", "root-ca"),
        ("intermediate-ca.pem", "intermediate-ca"),
        ("server.pem", "server"),
        ("client.pem", "client"),
        ("ec-p256.pem", "ec-p256"),
        ("ec-p384.pem", "ec-p384"),
        ("ed25519.pem", "ed25519"),
        ("expired.pem", "expired"),
        ("many-extensions.pem", "many-extensions"),
        ("minimal.pem", "minimal"),
    ];

    #[test]
    fn serial_matches_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-serial.txt", prefix));
            // OpenSSL format: "serial=XX"
            let ref_serial = ref_line.strip_prefix("serial=").unwrap_or(&ref_line);
            let expected = normalize_serial(ref_serial);
            let actual = cert.serial_hex().to_ascii_uppercase();

            assert_eq!(
                actual, expected,
                "serial mismatch for {}: got '{}', expected '{}'",
                cert_file, actual, expected
            );
        }
    }

    #[test]
    fn sha256_fingerprint_matches_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-fingerprint-sha256.txt", prefix));
            let expected = parse_fingerprint(&ref_line);
            let actual = cert.fingerprint(DigestAlgorithm::Sha256);

            assert_eq!(
                actual, expected,
                "SHA-256 fingerprint mismatch for {}",
                cert_file
            );
        }
    }

    #[test]
    fn sha1_fingerprint_matches_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-fingerprint-sha1.txt", prefix));
            let expected = parse_fingerprint(&ref_line);
            let actual = cert.fingerprint(DigestAlgorithm::Sha1);

            assert_eq!(
                actual, expected,
                "SHA-1 fingerprint mismatch for {}",
                cert_file
            );
        }
    }

    #[test]
    fn subject_components_match_reference() {
        // Only test ASCII subjects (skip utf8-subject which has encoding differences)
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-subject.txt", prefix));
            let ref_components = parse_dn_components(&ref_line);

            for (ref_key, ref_val) in &ref_components {
                let found = cert
                    .subject
                    .components
                    .iter()
                    .any(|(k, v)| k == ref_key && v == ref_val);
                assert!(
                    found,
                    "subject component {}={} from reference not found in {} (got: {})",
                    ref_key,
                    ref_val,
                    cert_file,
                    cert.subject_string()
                );
            }

            assert_eq!(
                cert.subject.components.len(),
                ref_components.len(),
                "subject component count mismatch for {} (got {}: {}, expected {}: {:?})",
                cert_file,
                cert.subject.components.len(),
                cert.subject_string(),
                ref_components.len(),
                ref_components,
            );
        }
    }

    #[test]
    fn issuer_components_match_reference() {
        for (cert_file, prefix) in CERTS {
            let data = load_cert(cert_file);
            let cert =
                parse_pem(&data).unwrap_or_else(|e| panic!("Failed to parse {}: {}", cert_file, e));

            let ref_line = load_reference(&format!("{}-issuer.txt", prefix));
            let ref_components = parse_dn_components(&ref_line);

            for (ref_key, ref_val) in &ref_components {
                let found = cert
                    .issuer
                    .components
                    .iter()
                    .any(|(k, v)| k == ref_key && v == ref_val);
                assert!(
                    found,
                    "issuer component {}={} from reference not found in {} (got: {})",
                    ref_key,
                    ref_val,
                    cert_file,
                    cert.issuer_string()
                );
            }

            assert_eq!(
                cert.issuer.components.len(),
                ref_components.len(),
                "issuer component count mismatch for {}",
                cert_file,
            );
        }
    }

    #[test]
    fn server_modulus_matches_reference() {
        let data = load_cert("server.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_line = load_reference("server-modulus.txt");
        // OpenSSL format: "Modulus=AABB..."
        let expected = ref_line
            .strip_prefix("Modulus=")
            .unwrap_or(&ref_line)
            .to_ascii_uppercase();

        let actual = cert
            .modulus_hex()
            .expect("server cert should have RSA modulus")
            .to_ascii_uppercase();

        assert_eq!(actual, expected, "modulus mismatch for server.pem");
    }

    #[test]
    fn server_email_matches_reference() {
        let data = load_cert("server.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_email = load_reference("server-email.txt");
        let emails = cert.emails();

        assert!(
            emails.iter().any(|e| e == &ref_email),
            "expected email '{}' not found in server.pem emails: {:?}",
            ref_email,
            emails
        );
    }

    #[test]
    fn server_ocsp_uri_matches_reference() {
        let data = load_cert("server.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_uri = load_reference("server-ocsp-uri.txt");
        let ocsp_urls = cert.ocsp_urls();

        assert!(
            ocsp_urls.iter().any(|u| u == &ref_uri),
            "expected OCSP URI '{}' not found in server.pem: {:?}",
            ref_uri,
            ocsp_urls
        );
    }

    #[test]
    fn client_email_matches_reference() {
        let data = load_cert("client.pem");
        let cert = parse_pem(&data).unwrap();

        let ref_email = load_reference("client-email.txt");
        let emails = cert.emails();

        assert!(
            emails.iter().any(|e| e == &ref_email),
            "expected email '{}' not found in client.pem emails: {:?}",
            ref_email,
            emails
        );
    }
}

// ---------------------------------------------------------------------------
// Name Constraints tests
// ---------------------------------------------------------------------------

mod name_constraints {
    use super::*;

    #[test]
    fn cert_within_name_constraints_verifies() {
        // nc-good.pem has DNS:www.example.com which is within nc-ca's
        // permitted constraint of DNS:example.com
        let nc_ca_data = load_cert("nc-ca.pem");
        let nc_good_data = load_cert("nc-good.pem");

        let mut trust_store = TrustStore::new();
        trust_store.add_pem_bundle(&nc_ca_data).unwrap();

        let good_der = pem_to_der(&nc_good_data).unwrap();
        let chain = vec![good_der];

        let result = verify_chain(&chain, &trust_store, None).unwrap();
        assert!(
            result.is_valid,
            "expected nc-good.pem to verify against nc-ca: {:?}",
            result.errors
        );
    }

    #[test]
    fn cert_violating_name_constraints_fails() {
        // nc-bad.pem has DNS:www.evil.com which is NOT within nc-ca's
        // permitted constraint of DNS:example.com
        let nc_ca_data = load_cert("nc-ca.pem");
        let nc_bad_data = load_cert("nc-bad.pem");

        let mut trust_store = TrustStore::new();
        trust_store.add_pem_bundle(&nc_ca_data).unwrap();

        let bad_der = pem_to_der(&nc_bad_data).unwrap();
        let chain = vec![bad_der];

        let result = verify_chain(&chain, &trust_store, None).unwrap();
        assert!(
            !result.is_valid,
            "expected nc-bad.pem to fail Name Constraints check"
        );
        assert!(
            result.errors.iter().any(|e| e.contains("Name Constraint")),
            "expected Name Constraint error, got: {:?}",
            result.errors
        );
    }

    #[test]
    fn nc_ca_has_name_constraints_extension() {
        let data = load_cert("nc-ca.pem");
        let cert = parse_pem(&data).unwrap();

        // The NC CA should have a Name Constraints extension
        let has_nc = cert.extensions.iter().any(|ext| ext.oid == "2.5.29.30");
        assert!(has_nc, "nc-ca.pem should have Name Constraints extension");
    }

    #[test]
    fn name_constraints_error_mentions_offending_name() {
        let nc_ca_data = load_cert("nc-ca.pem");
        let nc_bad_data = load_cert("nc-bad.pem");

        let mut trust_store = TrustStore::new();
        trust_store.add_pem_bundle(&nc_ca_data).unwrap();

        let bad_der = pem_to_der(&nc_bad_data).unwrap();
        let chain = vec![bad_der];

        let result = verify_chain(&chain, &trust_store, None).unwrap();
        assert!(!result.is_valid);

        // The error should mention the offending DNS name
        let nc_error = result
            .errors
            .iter()
            .find(|e| e.contains("Name Constraint"))
            .expect("should have Name Constraint error");
        assert!(
            nc_error.contains("evil.com"),
            "error should mention 'evil.com', got: {}",
            nc_error
        );
    }
}

// ---------------------------------------------------------------------------
// CRL revocation checking tests
// ---------------------------------------------------------------------------

mod crl_revocation {
    use super::*;

    fn load_crl() -> Vec<Vec<u8>> {
        let crl_data = std::fs::read(cert_path("test.crl.pem")).unwrap();
        parse_pem_crl(&crl_data).unwrap()
    }

    #[test]
    fn parse_crl_from_pem() {
        let crls = load_crl();
        assert!(!crls.is_empty(), "should parse at least one CRL");
    }

    #[test]
    fn revoked_cert_detected_by_crl_check() {
        // server.pem (serial 0x1000) was revoked in test.crl.pem
        let chain_data = load_cert("chain.pem");
        let root_data = load_cert("root-ca.pem");
        let crls = load_crl();

        let mut trust_store = TrustStore::new();
        trust_store.add_pem_bundle(&root_data).unwrap();

        let chain_ders = parse_pem_chain(&chain_data).unwrap();

        let options = VerifyOptions {
            crl_ders: crls,
            crl_check_leaf: true,
            ..VerifyOptions::default()
        };

        let result = verify_chain_with_options(&chain_ders, &trust_store, None, &options).unwrap();
        assert!(
            !result.is_valid,
            "revoked certificate should fail verification"
        );
        assert!(
            result.errors.iter().any(|e| e.contains("revoked")),
            "expected revocation error, got: {:?}",
            result.errors
        );
    }

    #[test]
    fn non_revoked_cert_passes_crl_check() {
        // client.pem (serial 0x1001) is NOT in the CRL
        let client_data = load_cert("client.pem");
        let intermediate_data = load_cert("intermediate-ca.pem");
        let root_data = load_cert("root-ca.pem");
        let crls = load_crl();

        let mut trust_store = TrustStore::new();
        trust_store.add_pem_bundle(&root_data).unwrap();

        let client_der = pem_to_der(&client_data).unwrap();
        let intermediate_der = pem_to_der(&intermediate_data).unwrap();
        let chain = vec![client_der, intermediate_der];

        let options = VerifyOptions {
            crl_ders: crls,
            crl_check_leaf: true,
            ..VerifyOptions::default()
        };

        let result = verify_chain_with_options(&chain, &trust_store, None, &options).unwrap();
        assert!(
            result.is_valid,
            "non-revoked cert should pass CRL check: {:?}",
            result.errors
        );
    }

    #[test]
    fn crl_check_all_checks_entire_chain() {
        // With crl_check_all, all certs in the chain are checked
        let chain_data = load_cert("chain.pem");
        let root_data = load_cert("root-ca.pem");
        let crls = load_crl();

        let mut trust_store = TrustStore::new();
        trust_store.add_pem_bundle(&root_data).unwrap();

        let chain_ders = parse_pem_chain(&chain_data).unwrap();

        let options = VerifyOptions {
            crl_ders: crls,
            crl_check_leaf: true,
            crl_check_all: true,
            ..VerifyOptions::default()
        };

        let result = verify_chain_with_options(&chain_ders, &trust_store, None, &options).unwrap();
        assert!(
            !result.is_valid,
            "revoked cert should fail with crl_check_all"
        );
    }

    #[test]
    fn without_crl_flags_no_revocation_check() {
        // Even with CRL data loaded, without crl_check flags no check is done
        let chain_data = load_cert("chain.pem");
        let root_data = load_cert("root-ca.pem");
        let crls = load_crl();

        let mut trust_store = TrustStore::new();
        trust_store.add_pem_bundle(&root_data).unwrap();

        let chain_ders = parse_pem_chain(&chain_data).unwrap();

        let options = VerifyOptions {
            crl_ders: crls,
            crl_check_leaf: false,
            crl_check_all: false,
            ..VerifyOptions::default()
        };

        let result = verify_chain_with_options(&chain_ders, &trust_store, None, &options).unwrap();
        assert!(
            result.is_valid,
            "without CRL check flags, revoked cert should still pass: {:?}",
            result.errors
        );
    }
}

// =========================================================================
// 11. VERIFY OPTIONS TESTS
// =========================================================================
//
// Tests for VerifyOptions fields: at_time, check_time, purpose,
// verify_email, verify_ip, verify_depth, partial_chain.
// Also tests resolve_purpose(), verify_with_untrusted(),
// verify_pem_chain_with_options(), TrustStore methods, and
// VerificationResult Display impl.

mod verify_options {
    use super::*;

    fn main_trust_store() -> TrustStore {
        let root_pem = load_cert("root-ca.pem");
        TrustStore::from_pem(&root_pem).expect("failed to create trust store from root CA")
    }

    fn main_chain_der() -> Vec<Vec<u8>> {
        let chain_pem = load_cert("chain.pem");
        parse_pem_chain(&chain_pem).expect("failed to parse chain")
    }

    // -----------------------------------------------------------------------
    // resolve_purpose
    // -----------------------------------------------------------------------

    #[test]
    fn resolve_purpose_named_values() {
        assert_eq!(resolve_purpose("sslserver"), Some("1.3.6.1.5.5.7.3.1"));
        assert_eq!(resolve_purpose("sslclient"), Some("1.3.6.1.5.5.7.3.2"));
        assert_eq!(resolve_purpose("codesign"), Some("1.3.6.1.5.5.7.3.3"));
        assert_eq!(resolve_purpose("smimesign"), Some("1.3.6.1.5.5.7.3.4"));
        assert_eq!(resolve_purpose("smimeencrypt"), Some("1.3.6.1.5.5.7.3.4"));
        assert_eq!(resolve_purpose("timestampsign"), Some("1.3.6.1.5.5.7.3.8"));
        assert_eq!(resolve_purpose("ocsphelper"), Some("1.3.6.1.5.5.7.3.9"));
        assert_eq!(resolve_purpose("any"), Some("2.5.29.37.0"));
    }

    #[test]
    fn resolve_purpose_unknown_returns_none() {
        assert_eq!(resolve_purpose("notapurpose"), None);
    }

    // -----------------------------------------------------------------------
    // at_time option
    // -----------------------------------------------------------------------

    #[test]
    fn verify_with_at_time_in_valid_period() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // Use timestamp in mid-2027 (well within 2026-2101 validity)
        let options = VerifyOptions {
            at_time: Some(1800000000),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "chain should verify with at_time in valid period: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_at_time_before_not_before() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // Epoch (1970-01-01) is before any cert's notBefore
        let options = VerifyOptions {
            at_time: Some(0),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            !result.is_valid,
            "chain should fail with at_time before notBefore"
        );
        assert!(
            result.errors.iter().any(|e| e.contains("not yet valid")),
            "should report 'not yet valid': {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_at_time_after_not_after() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // Year ~2200 is after notAfter (2101)
        let options = VerifyOptions {
            at_time: Some(7258118400),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            !result.is_valid,
            "chain should fail with at_time after notAfter"
        );
        assert!(
            result.errors.iter().any(|e| e.contains("expired")),
            "should report expired: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // check_time = false
    // -----------------------------------------------------------------------

    #[test]
    fn verify_with_no_check_time_ignores_dates() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // at_time=0 (epoch, before notBefore) would fail with time checks,
        // but check_time=false should skip all date validation
        let options = VerifyOptions {
            check_time: false,
            at_time: Some(0),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "chain should verify with check_time=false: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // purpose (EKU) option
    // -----------------------------------------------------------------------

    #[test]
    fn verify_with_purpose_server_auth_passes() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // server.pem has TLS Web Server Authentication EKU
        let options = VerifyOptions {
            purpose: Some("1.3.6.1.5.5.7.3.1".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "server cert should satisfy sslserver purpose: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_purpose_code_signing_fails() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // server.pem does NOT have Code Signing EKU
        let options = VerifyOptions {
            purpose: Some("1.3.6.1.5.5.7.3.3".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            !result.is_valid,
            "server cert should not satisfy codesign purpose"
        );
        assert!(
            result.errors.iter().any(|e| e.contains("EKU")),
            "should report missing EKU: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // verify_email option
    // -----------------------------------------------------------------------

    #[test]
    fn verify_with_email_match() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // server.pem has email:admin@example.com in SAN
        let options = VerifyOptions {
            verify_email: Some("admin@example.com".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "should pass with matching email: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_email_case_insensitive() {
        let chain = main_chain_der();
        let store = main_trust_store();
        let options = VerifyOptions {
            verify_email: Some("ADMIN@EXAMPLE.COM".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "email matching should be case-insensitive: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_email_no_match() {
        let chain = main_chain_der();
        let store = main_trust_store();
        let options = VerifyOptions {
            verify_email: Some("nobody@wrong.com".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(!result.is_valid, "should fail with non-matching email");
        assert!(
            result
                .errors
                .iter()
                .any(|e| e.contains("email") && e.contains("nobody@wrong.com")),
            "should report email mismatch: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // verify_ip option
    // -----------------------------------------------------------------------

    #[test]
    fn verify_with_ip_v4_match() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // server.pem has IP:93.184.216.34 in SAN
        let options = VerifyOptions {
            verify_ip: Some("93.184.216.34".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "should pass with matching IPv4: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_ip_v6_match() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // server.pem has IPv6 2606:2800:220:1:248:1893:25C8:1946
        let options = VerifyOptions {
            verify_ip: Some("2606:2800:220:1:248:1893:25c8:1946".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "should pass with matching IPv6: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_ip_no_match() {
        let chain = main_chain_der();
        let store = main_trust_store();
        let options = VerifyOptions {
            verify_ip: Some("1.2.3.4".into()),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(!result.is_valid, "should fail with non-matching IP");
        assert!(
            result
                .errors
                .iter()
                .any(|e| e.contains("IP") && e.contains("1.2.3.4")),
            "should report IP mismatch: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // verify_depth option
    // -----------------------------------------------------------------------

    #[test]
    fn verify_depth_exceeded() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // chain has 3 certs (leaf + intermediate + root). The root is self-signed
        // (subject == issuer), so only the intermediate counts as non-self-issued.
        // Setting max depth to 0 means zero non-self-issued intermediates  should fail.
        let options = VerifyOptions {
            verify_depth: Some(0),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options);
        assert!(
            result.is_err(),
            "should error when intermediates exceed verify_depth"
        );
    }

    #[test]
    fn verify_depth_exact_passes() {
        let chain = main_chain_der();
        let store = main_trust_store();
        // chain has 3 certs (leaf + intermediate + root). Only the intermediate
        // counts as non-self-issued (root is self-signed). Setting max depth to
        // 1 allows exactly 1 non-self-issued intermediate  should pass.
        let options = VerifyOptions {
            verify_depth: Some(1),
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "chain should pass when intermediates equals verify_depth: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // partial_chain option
    // -----------------------------------------------------------------------

    #[test]
    fn verify_partial_chain_with_intermediate_in_store() {
        let chain = main_chain_der();
        // Trust store contains only the intermediate CA (not the root)
        let intermediate_pem = load_cert("intermediate-ca.pem");
        let store =
            TrustStore::from_pem(&intermediate_pem).expect("create store from intermediate");
        let options = VerifyOptions {
            partial_chain: true,
            ..VerifyOptions::default()
        };
        let result = verify_chain_with_options(&chain, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "partial_chain should pass when intermediate is in store: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // verify_with_untrusted
    // -----------------------------------------------------------------------

    #[test]
    fn verify_with_untrusted_intermediates() {
        let leaf_pem = load_cert("server.pem");
        let leaf_der = pem_to_der(&leaf_pem).expect("parse leaf PEM");
        let intermediate_pem = load_cert("intermediate-ca.pem");
        let store = main_trust_store();
        let result = verify_with_untrusted(
            &leaf_der,
            &intermediate_pem,
            &store,
            None,
            &VerifyOptions::default(),
        )
        .expect("verification should not error");
        assert!(
            result.is_valid,
            "verify_with_untrusted should build chain: {:?}",
            result.errors
        );
    }

    #[test]
    fn verify_with_untrusted_and_hostname() {
        let leaf_pem = load_cert("server.pem");
        let leaf_der = pem_to_der(&leaf_pem).expect("parse leaf PEM");
        let intermediate_pem = load_cert("intermediate-ca.pem");
        let store = main_trust_store();
        let result = verify_with_untrusted(
            &leaf_der,
            &intermediate_pem,
            &store,
            Some("www.example.com"),
            &VerifyOptions::default(),
        )
        .expect("verification should not error");
        assert!(
            result.is_valid,
            "verify_with_untrusted + hostname should work: {:?}",
            result.errors
        );
    }

    // -----------------------------------------------------------------------
    // VerificationResult Display impl
    // -----------------------------------------------------------------------

    #[test]
    fn verification_result_display_ok() {
        let chain = main_chain_der();
        let store = main_trust_store();
        let result = verify_chain(&chain, &store, None).expect("verification should not error");
        assert!(result.is_valid);
        let display = format!("{}", result);
        assert!(
            display.starts_with("OK"),
            "display should start with OK: {}",
            display
        );
        assert!(
            display.contains("chain:"),
            "display should show chain: {}",
            display
        );
    }

    #[test]
    fn verification_result_display_fail() {
        let chain = main_chain_der();
        // Use a wrong trust store so verification fails
        let ec_root_pem =
            std::fs::read(cert_path("real/test-ec-root-ca.pem")).expect("read EC root");
        let store = TrustStore::from_pem(&ec_root_pem).expect("create EC store");
        let result = verify_chain(&chain, &store, None).expect("verification should not error");
        assert!(!result.is_valid);
        let display = format!("{}", result);
        assert!(
            display.starts_with("FAIL"),
            "display should start with FAIL: {}",
            display
        );
    }

    // -----------------------------------------------------------------------
    // TrustStore methods
    // -----------------------------------------------------------------------

    #[test]
    fn trust_store_from_pem_file() {
        let path = cert_path("root-ca.pem");
        let store =
            TrustStore::from_pem_file(&path).expect("should load trust store from PEM file");
        assert_eq!(store.len(), 1);
        assert!(!store.is_empty());
    }

    #[test]
    fn trust_store_from_pem_file_nonexistent() {
        let path = std::path::PathBuf::from("/nonexistent/path/cert.pem");
        let result = TrustStore::from_pem_file(&path);
        assert!(result.is_err(), "nonexistent file should error");
    }

    #[test]
    fn trust_store_add_pem_directory() {
        let dir = cert_path("real");
        let mut store = TrustStore::new();
        let added = store
            .add_pem_directory(&dir)
            .expect("should load certs from directory");
        assert!(added > 0, "should add at least one cert from directory");
        assert!(!store.is_empty());
    }

    #[test]
    fn trust_store_add_pem_directory_nonexistent() {
        let mut store = TrustStore::new();
        let result = store.add_pem_directory(std::path::Path::new("/nonexistent/dir"));
        assert!(result.is_err(), "nonexistent directory should error");
    }

    #[test]
    fn trust_store_default_is_empty() {
        let store: TrustStore = Default::default();
        assert!(store.is_empty());
        assert_eq!(store.len(), 0);
    }

    #[test]
    fn trust_store_debug_shows_count() {
        let store = main_trust_store();
        let debug = format!("{:?}", store);
        assert!(
            debug.contains("TrustStore"),
            "debug should show TrustStore: {}",
            debug
        );
        assert!(
            debug.contains("count"),
            "debug should show count: {}",
            debug
        );
    }

    // -----------------------------------------------------------------------
    // verify_pem_chain_with_options convenience function
    // -----------------------------------------------------------------------

    #[test]
    fn verify_pem_chain_with_options_works() {
        let chain_pem = load_cert("chain.pem");
        let store = main_trust_store();
        let options = VerifyOptions {
            at_time: Some(1800000000),
            ..VerifyOptions::default()
        };
        let result = verify_pem_chain_with_options(&chain_pem, &store, None, &options)
            .expect("verification should not error");
        assert!(
            result.is_valid,
            "verify_pem_chain_with_options should work: {:?}",
            result.errors
        );
    }
}

// =========================================================================
// 12. ADDITIONAL CHECK TESTS (CN fallback, IPv6 normalization)
// =========================================================================

mod check_additional {
    use super::*;

    #[test]
    fn hostname_cn_fallback_when_no_san_dns() {
        // minimal.pem has CN=Minimal Test but no SAN extension at all
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "Minimal Test"),
            "should match CN when no SAN DNS entries exist"
        );
    }

    #[test]
    fn hostname_cn_fallback_no_match() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "wrong.example.com"),
            "CN fallback should not match wrong hostname"
        );
    }

    #[test]
    fn ipv6_normalization_full_form() {
        // Test IPv6 matching with full leading-zero form
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "2606:2800:0220:0001:0248:1893:25c8:1946"),
            "should match full IPv6 with leading zeros"
        );
    }

    #[test]
    fn ipv6_normalization_compressed_form() {
        // Test IPv6 matching with compressed notation
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "2606:2800:220:1:248:1893:25c8:1946"),
            "should match compressed IPv6"
        );
    }

    #[test]
    fn ipv6_normalization_uppercase() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "2606:2800:0220:0001:0248:1893:25C8:1946"),
            "should match uppercase IPv6"
        );
    }
}

// =========================================================================
// 13. ADDITIONAL DISPLAY TESTS (CRL DP, Policies, NsComment, SAN variants)
// =========================================================================

mod display_additional {
    use super::*;

    #[test]
    fn display_crl_distribution_points() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("CRL Distribution Points"),
            "display should include CRL Distribution Points"
        );
        assert!(
            text.contains("crl.example.com"),
            "display should include CRL URI"
        );
    }

    #[test]
    fn display_certificate_policies() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Certificate Policies"),
            "display should include Certificate Policies"
        );
        assert!(
            text.contains("2.23.140.1.2.1"),
            "display should include policy OID"
        );
    }

    #[test]
    fn display_netscape_comment() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Netscape Comment"),
            "display should include Netscape Comment"
        );
        assert!(
            text.contains("test certificate"),
            "display should include comment text"
        );
    }

    #[test]
    fn display_text_show_all_includes_modulus() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, true);
        assert!(
            text.contains("Modulus:"),
            "show_all should include RSA modulus"
        );
    }

    #[test]
    fn display_san_email_and_ip_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Email: admin@example.com"),
            "display should show email SAN"
        );
        assert!(
            text.contains("IP: 93.184.216.34"),
            "display should show IPv4 SAN"
        );
    }

    #[test]
    fn display_server_crl_distribution_points() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("CRL Distribution Points"),
            "server display should include CRL DP"
        );
    }
}

// =========================================================================
// 14. ADDITIONAL PARSER / FIELDS TESTS
// =========================================================================
//
// Tests for extension parsing (CRL DP, Cert Policies, NsComment, AIA),
// Display impls, and IPv6 SAN formatting.

mod parser_fields_additional {
    use super::*;

    #[test]
    fn distinguished_name_display_impl() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let display = format!("{}", cert.subject);
        let oneline = cert.subject.to_oneline();
        assert_eq!(display, oneline, "Display impl should match to_oneline()");
        assert!(
            display.contains("CN = www.example.com"),
            "Display should contain CN: {}",
            display
        );
    }

    #[test]
    fn datetime_display_impl() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let display = format!("{}", cert.not_before);
        assert!(
            display.contains("2026"),
            "DateTime Display should show year: {}",
            display
        );
        assert!(
            display.contains("GMT"),
            "DateTime Display should show GMT: {}",
            display
        );
    }

    #[test]
    fn crl_distribution_points_parsed() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let cdp = cert
            .extensions
            .iter()
            .find(|e| e.name.contains("CRL Distribution"));
        assert!(cdp.is_some(), "server cert should have CRL DP extension");
        if let Some(ext) = cdp {
            match &ext.value {
                ExtensionValue::CrlDistributionPoints(uris) => {
                    assert!(!uris.is_empty(), "CRL DP should have URIs");
                    assert!(
                        uris.iter().any(|u| u.contains("crl.example.com")),
                        "CRL DP should contain example.com URI: {:?}",
                        uris
                    );
                }
                _ => panic!("expected CrlDistributionPoints variant"),
            }
        }
    }

    #[test]
    fn certificate_policies_parsed() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let cp = cert
            .extensions
            .iter()
            .find(|e| e.name.contains("Certificate Policies"));
        assert!(
            cp.is_some(),
            "many-extensions cert should have Certificate Policies"
        );
        if let Some(ext) = cp {
            match &ext.value {
                ExtensionValue::CertificatePolicies(oids) => {
                    assert!(!oids.is_empty(), "should have policy OIDs");
                    assert!(
                        oids.iter().any(|o| o == "2.23.140.1.2.1"),
                        "should include DV policy OID: {:?}",
                        oids
                    );
                }
                _ => panic!("expected CertificatePolicies variant"),
            }
        }
    }

    #[test]
    fn netscape_comment_parsed() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let ns = cert
            .extensions
            .iter()
            .find(|e| e.name.contains("Netscape Comment"));
        assert!(
            ns.is_some(),
            "many-extensions cert should have Netscape Comment"
        );
        if let Some(ext) = ns {
            match &ext.value {
                ExtensionValue::NsComment(comment) => {
                    assert!(
                        comment.contains("test certificate"),
                        "NsComment should contain expected text: {}",
                        comment
                    );
                }
                _ => panic!("expected NsComment variant"),
            }
        }
    }

    #[test]
    fn server_aia_has_ocsp_and_ca_issuers() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let aia = cert
            .extensions
            .iter()
            .find(|e| e.name.contains("Authority Information Access"));
        assert!(aia.is_some(), "server should have AIA extension");
        if let Some(ext) = aia {
            match &ext.value {
                ExtensionValue::AuthorityInfoAccess(entries) => {
                    assert!(
                        entries.iter().any(|e| e.method == "OCSP"),
                        "should have OCSP method"
                    );
                    assert!(
                        entries.iter().any(|e| e.method == "CA Issuers"),
                        "should have CA Issuers method"
                    );
                }
                _ => panic!("expected AuthorityInfoAccess variant"),
            }
        }
    }

    #[test]
    fn ipv6_san_format_is_uppercase_hex() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        let ips: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Ip(ip) => Some(ip.as_str()),
                _ => None,
            })
            .collect();
        // Find the IPv6 entry (longer than 15 chars)
        let ipv6 = ips.iter().find(|ip| ip.contains(':') && ip.len() > 15);
        assert!(ipv6.is_some(), "should have IPv6 SAN: {:?}", ips);
        let ipv6_str = ipv6.unwrap();
        // Should be uppercase hex format like "2606:2800:220:1:248:1893:25C8:1946"
        assert!(
            ipv6_str.contains("2606"),
            "IPv6 should contain expected prefix: {}",
            ipv6_str
        );
        assert!(
            ipv6_str.contains("25C8"),
            "IPv6 should be uppercase hex: {}",
            ipv6_str
        );
    }
}

// =========================================================================
// 24. x509-limbo TEST VECTORS (C2SP)
// =========================================================================
//
// Test vectors from https://github.com/C2SP/x509-limbo (git submodule at
// tests/x509-limbo/). Reads the upstream limbo.json directly and filters
// at runtime. Tests skip gracefully if the submodule is not initialized.
//
// To initialize:  git submodule update --init tests/x509-limbo
// To update:      git submodule update --remote tests/x509-limbo

mod limbo {
    use serde::Deserialize;
    use std::collections::HashSet;
    use time::format_description::well_known::Rfc3339;
    use time::OffsetDateTime;
    use xcert_lib::*;

    // --- Original limbo.json schema types ---

    #[derive(Deserialize)]
    struct LimboFile {
        #[allow(dead_code)]
        version: u32,
        testcases: Vec<LimboTestcase>,
    }

    #[derive(Deserialize)]
    struct LimboTestcase {
        id: String,
        #[allow(dead_code)]
        description: String,
        validation_kind: String,
        trusted_certs: Vec<String>,
        untrusted_intermediates: Vec<String>,
        peer_certificate: String,
        #[allow(dead_code)]
        signature_algorithms: Vec<String>,
        key_usage: Vec<String>,
        extended_key_usage: Vec<String>,
        expected_result: String,
        #[allow(dead_code)]
        expected_peer_names: Vec<serde_json::Value>,
        expected_peer_name: Option<PeerName>,
        validation_time: Option<String>,
        max_chain_depth: Option<usize>,
        #[serde(default)]
        crls: Vec<String>,
        #[allow(dead_code)]
        #[serde(default)]
        features: Vec<String>,
    }

    #[derive(Deserialize)]
    struct PeerName {
        kind: String,
        value: String,
    }

    // --- Filtered / mapped test representation ---

    struct PreparedTest {
        id: String,
        trusted_pem: String,
        chain_pem: String,
        hostname: Option<String>,
        ip: Option<String>,
        at_time: Option<i64>,
        max_depth: Option<usize>,
        crls_pem: Vec<String>,
        purpose: Option<String>,
        expect_success: bool,
        policy: VerifyPolicy,
    }

    fn limbo_json_path() -> std::path::PathBuf {
        let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        p.pop();
        p.push("tests");
        p.push("x509-limbo");
        p.push("limbo.json");
        p
    }

    fn load_and_filter() -> Option<Vec<PreparedTest>> {
        let path = limbo_json_path();
        let data = match std::fs::read_to_string(&path) {
            Ok(d) => d,
            Err(_) => return None, // submodule not initialized
        };
        let file: LimboFile = serde_json::from_str(&data).expect("Failed to parse limbo.json");

        let eku_map: std::collections::HashMap<&str, &str> = [
            ("serverAuth", "sslserver"),
            ("clientAuth", "sslclient"),
            ("codeSigning", "codesign"),
            ("emailProtection", "smimesign"),
            ("timeStamping", "timestampsign"),
            ("OCSPSigning", "ocsphelper"),
            ("anyExtendedKeyUsage", "any"),
        ]
        .into_iter()
        .collect();

        let tests = file
            .testcases
            .into_iter()
            .filter(|tc| {
                // Skip CLIENT validation (we only verify SERVER)
                if tc.validation_kind != "SERVER" {
                    return false;
                }
                // Skip categories we exclude
                if tc.id.starts_with("bettertls::nameconstraints") || tc.id.starts_with("online") {
                    return false;
                }
                // Skip tests with key_usage constraints (not supported)
                if !tc.key_usage.is_empty() {
                    return false;
                }
                true
            })
            .map(|tc| {
                // Build chain PEM: peer_certificate + untrusted intermediates
                let mut chain_pem = tc.peer_certificate;
                for intermediate in &tc.untrusted_intermediates {
                    chain_pem.push_str(intermediate);
                }

                // Build trusted PEM bundle
                let trusted_pem: String = tc.trusted_certs.concat();

                // Parse validation_time ISO 8601  unix timestamp
                let at_time = tc.validation_time.as_deref().and_then(|s| {
                    OffsetDateTime::parse(s, &Rfc3339)
                        .ok()
                        .map(|dt| dt.unix_timestamp())
                });

                // Extract hostname or IP from expected_peer_name
                let mut hostname = None;
                let mut ip = None;
                if let Some(ref pn) = tc.expected_peer_name {
                    match pn.kind.as_str() {
                        "DNS" => hostname = Some(pn.value.clone()),
                        "IP" => ip = Some(pn.value.clone()),
                        _ => {}
                    }
                }

                // Map EKU to purpose name
                let purpose = tc
                    .extended_key_usage
                    .iter()
                    .find_map(|eku| eku_map.get(eku.as_str()).map(|s| (*s).to_string()));

                let policy = if tc.id.starts_with("webpki::") {
                    VerifyPolicy::WebPki
                } else {
                    VerifyPolicy::Rfc5280
                };

                PreparedTest {
                    id: tc.id,
                    trusted_pem,
                    chain_pem,
                    hostname,
                    ip,
                    at_time,
                    max_depth: tc.max_chain_depth,
                    crls_pem: tc.crls,
                    purpose,
                    expect_success: tc.expected_result == "SUCCESS",
                    policy,
                }
            })
            .collect();

        Some(tests)
    }

    /// Known failures with documented reasons. These are tracked limitations,
    /// not bugs. If any of these start passing, that's an improvement.
    ///
    /// Categories:
    /// - PATH_BUILDING: We verify chains as-given; we don't build paths from
    ///   a pool of untrusted intermediates.
    ///
    /// Remaining known failures after implementing: self-issued exemptions,
    /// RFC 5280 strict validation, CRL strict, NC DoS protection, WebPKI
    /// policy mode, and DFS path building.
    fn known_failures() -> HashSet<&'static str> {
        [
            // PATH_BUILDING: DFS path builder finds valid alternative chains
            // where these tests expect failure (the valid chain bypasses the
            // intended constraint violation).
            "bettertls::pathbuilding::tc5",
            "bettertls::pathbuilding::tc12",
            "bettertls::pathbuilding::tc38",
            "bettertls::pathbuilding::tc44",
            "bettertls::pathbuilding::tc50",
            "bettertls::pathbuilding::tc52",
            "bettertls::pathbuilding::tc53",
            "bettertls::pathbuilding::tc56",
            "bettertls::pathbuilding::tc58",
            "bettertls::pathbuilding::tc59",
            "bettertls::pathbuilding::tc71",
            "bettertls::pathbuilding::tc77",
            // RFC5280_STRICT: AKI/SKI criticality checks not yet fully enforced.
            "rfc5280::aki::critical-aki",
            "rfc5280::aki::cross-signed-root-missing-aki",
            "rfc5280::ski::critical-ski",
            // RFC5280_STRICT: SAN validation edge cases.
            "rfc5280::san::malformed",
            "rfc5280::san::underscore-dns",
            // RFC5280_STRICT: Leaf KU keyCertSign (RFC 5280 allows CA-as-leaf).
            "rfc5280::leaf-ku-keycertsign",
            // RFC5280_STRICT: CA with empty subject validation.
            "rfc5280::ca-empty-subject",
            // NAME_CONSTRAINTS: Edge cases in name constraint validation.
            "rfc5280::nc::invalid-dnsname-leading-period",
            "rfc5280::nc::nc-forbids-othername",
            "rfc5280::nc::nc-forbids-same-chain-ica",
            "rfc5280::nc::nc-permits-invalid-dns-san",
            // WEBPKI_POLICY: CN matching restrictions (WebPKI requires SAN,
            // CABF BR 7.1.4.3 CN format rules for IP addresses).
            "webpki::cn::case-mismatch",
            "webpki::cn::ipv4-hex-mismatch",
            "webpki::cn::ipv4-leading-zeros-mismatch",
            "webpki::cn::ipv6-non-rfc5952-mismatch",
            "webpki::cn::ipv6-uncompressed-mismatch",
            "webpki::cn::ipv6-uppercase-mismatch",
            "webpki::cn::not-in-san",
            "webpki::cn::punycode-not-in-san",
            "webpki::cn::utf8-vs-punycode-mismatch",
            // WEBPKI_POLICY: Weak crypto edge cases (RSA key not divisible by 8).
            "webpki::forbidden-rsa-key-not-divisable-by-8-in-leaf",
            "webpki::forbidden-rsa-not-divisable-by-8-in-root",
            // WEBPKI_POLICY: Name constraint non-critical NC (CABF exception).
            "webpki::nc::permitted-dns-match-noncritical",
        ]
        .into_iter()
        .collect()
    }

    fn run_limbo_test(tc: &PreparedTest) -> (bool, String) {
        // Build trust store
        let mut trust_store = TrustStore::default();
        if !tc.trusted_pem.is_empty() {
            if let Err(e) = trust_store.add_pem_bundle(tc.trusted_pem.as_bytes()) {
                if tc.expect_success {
                    return (false, format!("Failed to load trust store: {}", e));
                }
                return (true, String::new());
            }
        }

        // Build verify options
        let mut options = VerifyOptions {
            check_time: true,
            partial_chain: false,
            policy: tc.policy,
            ..VerifyOptions::default()
        };

        if let Some(at_time) = tc.at_time {
            options.at_time = Some(at_time);
        }

        if let Some(depth) = tc.max_depth {
            options.verify_depth = Some(depth);
        }

        if let Some(ref purpose_name) = tc.purpose {
            if let Some(oid) = resolve_purpose(purpose_name) {
                options.purpose = Some(oid.to_string());
            }
        }

        // Parse CRLs
        for crl_pem in &tc.crls_pem {
            match parse_pem_crl(crl_pem.as_bytes()) {
                Ok(crl_ders) => {
                    options.crl_ders.extend(crl_ders);
                    options.crl_check_all = true;
                }
                Err(e) => {
                    if tc.expect_success {
                        return (false, format!("Failed to parse CRL: {}", e));
                    }
                    return (true, String::new());
                }
            }
        }

        // Determine hostname for verification
        let hostname = tc.hostname.as_deref().or(tc.ip.as_deref());

        // If IP is specified, set verify_ip in options
        if let Some(ref ip) = tc.ip {
            options.verify_ip = Some(ip.clone());
        }

        // Run verification
        let result = verify_pem_chain_with_options(
            tc.chain_pem.as_bytes(),
            &trust_store,
            hostname,
            &options,
        );

        let actual_success = match &result {
            Ok(r) => r.is_valid,
            Err(_) => false,
        };

        let context = match &result {
            Ok(r) if !r.is_valid => format!("errors: {:?}", r.errors),
            Err(e) => format!("error: {}", e),
            _ => String::new(),
        };

        (actual_success == tc.expect_success, context)
    }

    /// Run a category of limbo tests. Panics on unexpected failures
    /// (regressions) but tolerates known failures.
    fn run_category(tests: &[&PreparedTest], known: &HashSet<&str>, label: &str) {
        assert!(!tests.is_empty(), "No {} tests found", label);

        let mut passed = 0;
        let mut known_failed = 0;
        let mut known_now_passing = Vec::new();
        let mut regressions = Vec::new();

        for tc in tests {
            let (ok, context) = run_limbo_test(tc);
            let is_known = known.contains(tc.id.as_str());

            if ok {
                passed += 1;
                if is_known {
                    known_now_passing.push(tc.id.as_str());
                }
            } else if is_known {
                known_failed += 1;
            } else {
                regressions.push(format!(
                    "  {} (expected {}): {}",
                    tc.id,
                    if tc.expect_success {
                        "SUCCESS"
                    } else {
                        "FAILURE"
                    },
                    context
                ));
            }
        }

        if !known_now_passing.is_empty() {
            eprintln!(
                "limbo {}: {} known failures now passing (consider removing from known_failures):",
                label,
                known_now_passing.len()
            );
            for id in &known_now_passing {
                eprintln!("  + {}", id);
            }
        }

        eprintln!(
            "limbo {}: {}/{} passed, {} known failures",
            label,
            passed,
            tests.len(),
            known_failed
        );

        if !regressions.is_empty() {
            panic!(
                "limbo {}: {} unexpected failures (regressions):\n{}",
                label,
                regressions.len(),
                regressions.join("\n")
            );
        }
    }

    /// Load tests or skip if submodule is not initialized.
    macro_rules! limbo_tests_or_skip {
        () => {
            match load_and_filter() {
                Some(tests) => tests,
                None => {
                    eprintln!(
                        "skipping limbo tests: submodule not initialized \
                         (run: git submodule update --init tests/x509-limbo)"
                    );
                    return;
                }
            }
        };
    }

    #[test]
    fn limbo_rfc5280_vectors() {
        let suite = limbo_tests_or_skip!();
        let known = known_failures();
        let tests: Vec<_> = suite
            .iter()
            .filter(|t| t.id.starts_with("rfc5280::"))
            .collect();
        run_category(&tests, &known, "rfc5280");
    }

    #[test]
    fn limbo_webpki_vectors() {
        let suite = limbo_tests_or_skip!();
        let known = known_failures();
        let tests: Vec<_> = suite
            .iter()
            .filter(|t| t.id.starts_with("webpki::"))
            .collect();
        run_category(&tests, &known, "webpki");
    }

    #[test]
    fn limbo_pathlen_vectors() {
        let suite = limbo_tests_or_skip!();
        let known = known_failures();
        let tests: Vec<_> = suite
            .iter()
            .filter(|t| t.id.starts_with("pathlen::"))
            .collect();
        run_category(&tests, &known, "pathlen");
    }

    #[test]
    fn limbo_pathbuilding_vectors() {
        let suite = limbo_tests_or_skip!();
        let known = known_failures();
        let tests: Vec<_> = suite
            .iter()
            .filter(|t| t.id.starts_with("bettertls::pathbuilding::"))
            .collect();
        run_category(&tests, &known, "pathbuilding");
    }

    #[test]
    fn limbo_crl_vectors() {
        let suite = limbo_tests_or_skip!();
        let known = known_failures();
        let tests: Vec<_> = suite.iter().filter(|t| t.id.starts_with("crl::")).collect();
        run_category(&tests, &known, "crl");
    }

    #[test]
    fn limbo_pathological_and_edge_cases() {
        let suite = limbo_tests_or_skip!();
        let known = known_failures();
        let tests: Vec<_> = suite
            .iter()
            .filter(|t| {
                t.id.starts_with("pathological::")
                    || t.id.starts_with("cve::")
                    || t.id.starts_with("invalid::")
            })
            .collect();
        run_category(&tests, &known, "pathological/edge");
    }

    /// Aggregate summary: reports overall limbo pass rate. Fails only if
    /// there are unexpected regressions (tests not in known_failures).
    #[test]
    fn limbo_all_vectors_summary() {
        let suite = limbo_tests_or_skip!();
        let known = known_failures();
        let tests: Vec<_> = suite.iter().collect();
        run_category(&tests, &known, "ALL");
    }
}
