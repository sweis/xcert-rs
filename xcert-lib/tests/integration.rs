//! Integration tests for xcert-lib using generated test certificates.
//!
//! Test certificates are in tests/certs/ (generated by tests/certs/generate.sh).
//! Reference outputs from openssl x509 are in tests/certs/reference/.
//!
//! These tests exercise the library API against known-good certificates and
//! compare results to openssl x509 output where applicable.

use xcert_lib::*;

// ---------------------------------------------------------------------------
// Helper: load a test certificate file
// ---------------------------------------------------------------------------

fn cert_path(name: &str) -> std::path::PathBuf {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop(); // up from xcert-lib to workspace root
    p.push("tests");
    p.push("certs");
    p.push(name);
    p
}

fn load_cert(name: &str) -> Vec<u8> {
    std::fs::read(cert_path(name)).unwrap_or_else(|e| {
        panic!(
            "Failed to read test certificate '{}': {}. Run tests/certs/generate.sh first.",
            name, e
        )
    })
}

fn load_reference(name: &str) -> String {
    let mut p = cert_path("reference");
    p.pop();
    p.push("reference");
    p.push(name);
    std::fs::read_to_string(&p).unwrap_or_else(|e| {
        panic!(
            "Failed to read reference file '{}': {}. Run tests/certs/generate.sh first.",
            name, e
        )
    })
}

// =========================================================================
// 1. PARSING TESTS
// =========================================================================

mod parsing {
    use super::*;

    #[test]
    fn parse_rsa_pem() {
        let data = load_cert("root-ca.pem");
        let cert = parse_pem(&data).expect("should parse root CA PEM");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_rsa_der() {
        let data = load_cert("root-ca.der");
        let cert = parse_der(&data).expect("should parse root CA DER");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_pem() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).expect("should auto-detect PEM and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_der() {
        let data = load_cert("server.der");
        let cert = parse_cert(&data).expect("should auto-detect DER and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_ec_p256() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).expect("should parse ECDSA P-256 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "EC");
    }

    #[test]
    fn parse_ec_p384() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).expect("should parse ECDSA P-384 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "EC");
    }

    #[test]
    fn parse_ed25519() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).expect("should parse Ed25519 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "Ed25519");
    }

    #[test]
    fn parse_minimal_self_signed() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).expect("should parse minimal cert");
        // Minimal cert created with -subj "/CN=Minimal Test"
        assert!(cert.subject_string().contains("Minimal Test"));
    }

    #[test]
    fn parse_expired_cert() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).expect("should parse expired cert");
        assert!(cert.subject_string().contains("Expired Test"));
    }

    #[test]
    fn parse_many_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).expect("should parse cert with many extensions");
        assert!(!cert.extensions.is_empty(), "should have extensions");
    }

    #[test]
    fn parse_utf8_subject() {
        let data = load_cert("utf8-subject.pem");
        let cert = parse_cert(&data).expect("should parse cert with UTF-8 subject");
        // Should contain French characters
        let subject = cert.subject_string();
        assert!(
            subject.contains("Paris") || subject.contains("France"),
            "UTF-8 subject should contain French location, got: {}",
            subject
        );
    }

    #[test]
    fn parse_chain_takes_first_cert() {
        let data = load_cert("chain.pem");
        let cert = parse_cert(&data).expect("should parse first cert in chain");
        // chain.pem = server + intermediate + root; first should be server
        assert!(cert.subject_string().contains("www.example.com"));
    }

    #[test]
    fn parse_invalid_data_returns_error() {
        let data = b"this is not a certificate";
        assert!(parse_cert(data).is_err());
    }

    #[test]
    fn parse_empty_input_returns_error() {
        assert!(parse_cert(b"").is_err());
    }

    #[test]
    fn parse_truncated_der_returns_error() {
        let data = load_cert("root-ca.der");
        let truncated = &data[..data.len() / 2];
        assert!(parse_der(truncated).is_err());
    }
}

// =========================================================================
// 2. FIELD EXTRACTION TESTS
// =========================================================================

mod fields {
    use super::*;

    // --- Subject ---

    #[test]
    fn root_ca_subject() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(subject.contains("Test Root CA"), "subject: {}", subject);
        assert!(subject.contains("US"), "subject should contain country");
        assert!(
            subject.contains("Test PKI"),
            "subject should contain org"
        );
    }

    #[test]
    fn server_subject() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("www.example.com"),
            "subject: {}",
            subject
        );
        assert!(
            subject.contains("Example Corp"),
            "subject should contain org"
        );
    }

    #[test]
    fn ec_p256_subject() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("ec-test.example.com"),
            "subject: {}",
            subject
        );
        assert!(subject.contains("DE"), "subject should contain country DE");
    }

    #[test]
    fn ed25519_subject() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("ed25519.example.com"),
            "subject: {}",
            subject
        );
    }

    // --- Issuer ---

    #[test]
    fn root_ca_is_self_signed() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(
            cert.subject_string(),
            cert.issuer_string(),
            "root CA should be self-signed"
        );
    }

    #[test]
    fn server_issuer_is_intermediate() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let issuer = cert.issuer_string();
        assert!(
            issuer.contains("Test Intermediate CA"),
            "issuer: {}",
            issuer
        );
    }

    #[test]
    fn intermediate_issuer_is_root() {
        let data = load_cert("intermediate-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let issuer = cert.issuer_string();
        assert!(issuer.contains("Test Root CA"), "issuer: {}", issuer);
    }

    // --- Serial ---

    #[test]
    fn root_ca_serial() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let serial = cert.serial_hex();
        // openssl reports serial=01
        assert!(
            serial == "01" || serial == "1",
            "root CA serial should be 01, got: {}",
            serial
        );
    }

    #[test]
    fn server_serial() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let serial = cert.serial_hex();
        // openssl reports serial=1000
        assert!(
            serial.to_uppercase().contains("1000"),
            "server serial should contain 1000, got: {}",
            serial
        );
    }

    // --- Dates ---

    #[test]
    fn server_dates_are_reasonable() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // not_before should be in 2026
        assert!(
            cert.not_before_string().contains("2026"),
            "not_before: {}",
            cert.not_before_string()
        );
        // not_after should be in 2101 (75 year validity)
        assert!(
            cert.not_after_string().contains("2101"),
            "not_after: {}",
            cert.not_after_string()
        );
    }

    #[test]
    fn expired_cert_dates() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // The expired cert has 1-day validity
        let not_before = cert.not_before_string();
        let not_after = cert.not_after_string();
        assert!(!not_before.is_empty(), "not_before should not be empty");
        assert!(!not_after.is_empty(), "not_after should not be empty");
    }

    // --- Public Key Info ---

    #[test]
    fn server_rsa_2048_key() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
    }

    #[test]
    fn ec_p256_key_info() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(
            cert.public_key.curve.as_deref(),
            Some("P-256"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ec_p384_key_info() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(
            cert.public_key.curve.as_deref(),
            Some("P-384"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ed25519_key_info() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "Ed25519");
    }

    #[test]
    fn rsa_modulus_present() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let modulus = cert.modulus_hex();
        assert!(modulus.is_some(), "RSA cert should have modulus");
        let modulus = modulus.unwrap();
        assert!(!modulus.is_empty(), "modulus should not be empty");
    }

    #[test]
    fn ec_has_no_modulus() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.modulus_hex().is_none(),
            "EC cert should not have modulus"
        );
    }

    #[test]
    fn public_key_pem_format() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let pem = cert.public_key_pem();
        assert!(
            pem.contains("BEGIN PUBLIC KEY"),
            "public key PEM should have header"
        );
        assert!(
            pem.contains("END PUBLIC KEY"),
            "public key PEM should have footer"
        );
    }

    // --- Signature Algorithm ---

    #[test]
    fn server_sha256_rsa_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha256")
                || cert.signature_algorithm.contains("SHA256")
                || cert.signature_algorithm.contains("sha256WithRSAEncryption"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }

    #[test]
    fn ec_p384_sha384_signature() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha384")
                || cert.signature_algorithm.contains("SHA384")
                || cert.signature_algorithm.contains("ecdsa-with-SHA384"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }
}

// =========================================================================
// 3. EXTENSION TESTS
// =========================================================================

mod extensions {
    use super::*;

    #[test]
    fn root_ca_is_ca() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "root CA should have BasicConstraints");
        if let Some(ext) = bc {
            assert!(ext.critical, "BasicConstraints should be critical on CA");
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(ca, "CA flag should be true");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn intermediate_ca_pathlen_zero() {
        let data = load_cert("intermediate-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "intermediate CA should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, path_len } => {
                    assert!(ca, "CA flag should be true");
                    assert_eq!(*path_len, Some(0), "pathlen should be 0");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_not_ca() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "server should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(!ca, "server CA flag should be false");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "server should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter().any(|u| u.contains("Digital Signature") || u.contains("digitalSignature")),
            "should include Digital Signature, got: {:?}",
            ku
        );
        assert!(
            ku.iter().any(|u| u.contains("Key Encipherment") || u.contains("keyEncipherment")),
            "should include Key Encipherment, got: {:?}",
            ku
        );
    }

    #[test]
    fn server_extended_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "server should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter().any(|u| u.contains("Server") || u.contains("serverAuth")),
            "should include serverAuth, got: {:?}",
            eku
        );
    }

    #[test]
    fn client_extended_key_usage() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "client should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter().any(|u| u.contains("Client") || u.contains("clientAuth")),
            "should include clientAuth, got: {:?}",
            eku
        );
        assert!(
            eku.iter().any(|u| u.contains("Email") || u.contains("emailProtection")),
            "should include emailProtection, got: {:?}",
            eku
        );
    }

    #[test]
    fn server_san_dns_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        assert!(!san.is_empty(), "server should have SAN entries");

        let dns_names: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Dns(name) => Some(name.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            dns_names.contains(&"www.example.com"),
            "should contain www.example.com, got: {:?}",
            dns_names
        );
        assert!(
            dns_names.contains(&"example.com"),
            "should contain example.com"
        );
        assert!(
            dns_names.contains(&"*.example.com"),
            "should contain *.example.com"
        );
    }

    #[test]
    fn server_san_ip_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let ips: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Ip(ip) => Some(ip.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            ips.iter().any(|ip| ip.contains("93.184.216.34")),
            "should contain IPv4 93.184.216.34, got: {:?}",
            ips
        );
        // IPv6 address
        assert!(
            ips.iter().any(|ip| ip.to_lowercase().contains("2606:2800")),
            "should contain IPv6 address, got: {:?}",
            ips
        );
    }

    #[test]
    fn server_san_email_entry() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let emails: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Email(email) => Some(email.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            emails.contains(&"admin@example.com"),
            "should contain admin@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn server_authority_info_access() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let ocsp_urls = cert.ocsp_urls();
        assert!(
            ocsp_urls.iter().any(|u| u.contains("ocsp.example.com")),
            "should have OCSP URL, got: {:?}",
            ocsp_urls
        );
    }

    #[test]
    fn many_extensions_cert_has_expected_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();

        let ext_names: Vec<&str> = cert.extensions.iter().map(|e| e.name.as_str()).collect();

        // Should have at least: BasicConstraints, KeyUsage, ExtendedKeyUsage, SKI, AKI, SAN, AIA, CRL DP
        assert!(
            ext_names.iter().any(|n| n.contains("Basic")),
            "should have BasicConstraints"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Key Usage") && !n.contains("Extended")),
            "should have KeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Extended")),
            "should have ExtendedKeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Subject Alternative")),
            "should have SubjectAltName"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Authority Information")),
            "should have AuthorityInfoAccess"
        );
    }

    #[test]
    fn many_extensions_eku_values() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some());
        let eku = eku.unwrap();
        // Should include: serverAuth, clientAuth, codeSigning, emailProtection, timeStamping
        assert!(
            eku.len() >= 5,
            "should have at least 5 EKU values, got {} : {:?}",
            eku.len(),
            eku
        );
    }

    #[test]
    fn many_extensions_san_has_uri() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let uris: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Uri(u) => Some(u.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            uris.iter().any(|u| u.contains("example.com/cert-info")),
            "should contain URI SAN, got: {:?}",
            uris
        );
    }

    #[test]
    fn root_ca_key_usage_includes_cert_sign() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "root CA should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter().any(|u| u.contains("Cert Sign") || u.contains("keyCertSign") || u.contains("Certificate Sign")),
            "root CA should have keyCertSign, got: {:?}",
            ku
        );
    }

    #[test]
    fn minimal_cert_has_no_san() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        // A minimal self-signed cert may or may not have SAN depending on openssl defaults
        // But our explicitly minimal cert should have minimal extensions
        // This is a structural test -- we mainly verify it doesn't crash
        let _ = san;
    }
}

// =========================================================================
// 4. FINGERPRINT TESTS
// =========================================================================

mod fingerprints {
    use super::*;

    #[test]
    fn root_ca_sha256_fingerprint() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        assert_eq!(
            fp.to_uppercase(),
            "B3:33:1D:8E:18:2E:E1:27:6A:4E:E1:B7:A8:A6:E0:1D:47:54:38:4F:B1:E4:79:C7:F3:95:4B:6F:F1:B3:E4:A2",
            "SHA-256 fingerprint mismatch"
        );
    }

    #[test]
    fn root_ca_sha1_fingerprint() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha1);
        assert_eq!(
            fp.to_uppercase(),
            "C6:98:03:8E:D0:B6:9C:25:B1:15:32:B8:BA:0B:72:FC:62:C3:86:60",
            "SHA-1 fingerprint mismatch"
        );
    }

    #[test]
    fn server_sha256_fingerprint() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        assert_eq!(
            fp.to_uppercase(),
            "ED:D7:70:25:25:CC:22:0C:62:0D:FA:CD:96:DE:9E:AE:83:32:9A:AD:D7:70:BB:43:DF:F7:70:93:52:94:7E:C7",
            "SHA-256 fingerprint mismatch"
        );
    }

    #[test]
    fn many_extensions_sha256_fingerprint() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        assert_eq!(
            fp.to_uppercase(),
            "23:D7:85:CF:FF:CF:EC:48:D2:FF:51:26:AE:06:80:53:BD:6E:7F:0D:A1:0E:D4:57:EF:9B:86:28:AF:9D:BC:40",
            "SHA-256 fingerprint mismatch"
        );
    }

    #[test]
    fn fingerprint_from_pem_matches_der() {
        let pem_data = load_cert("root-ca.pem");
        let der_data = load_cert("root-ca.der");
        let pem_cert = parse_pem(&pem_data).unwrap();
        let der_cert = parse_der(&der_data).unwrap();
        assert_eq!(
            pem_cert.fingerprint(DigestAlgorithm::Sha256),
            der_cert.fingerprint(DigestAlgorithm::Sha256),
            "PEM and DER should produce the same fingerprint"
        );
    }

    #[test]
    fn sha384_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha384);
        // SHA-384 = 48 bytes = 48*3-1 = 143 chars in colon-separated hex
        assert_eq!(fp.len(), 143, "SHA-384 fingerprint wrong length: {}", fp);
    }

    #[test]
    fn sha512_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha512);
        // SHA-512 = 64 bytes = 64*3-1 = 191 chars in colon-separated hex
        assert_eq!(fp.len(), 191, "SHA-512 fingerprint wrong length: {}", fp);
    }
}

// =========================================================================
// 5. EMAIL EXTRACTION TESTS
// =========================================================================

mod emails {
    use super::*;

    #[test]
    fn server_emails() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(
            emails.contains(&"admin@example.com".to_string()),
            "should contain admin@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn client_emails() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(
            emails.contains(&"client@example.com".to_string()),
            "should contain client@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn root_ca_no_emails() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(emails.is_empty(), "root CA should have no emails");
    }
}

// =========================================================================
// 6. CHECK TESTS
// =========================================================================

mod checks {
    use super::*;

    // --- Expiry ---

    #[test]
    fn server_not_expired() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // Server cert valid until 2101; checking with 0 seconds means "is it valid now?"
        assert!(
            check_expiry(&cert, 0),
            "server cert should not be expired"
        );
    }

    #[test]
    fn server_valid_for_one_year() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_expiry(&cert, 365 * 24 * 60 * 60),
            "server cert should be valid for at least 1 year"
        );
    }

    #[test]
    fn expired_cert_is_expired() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // Check if it expires within 10 years (it already has since it was 1-day)
        assert!(
            !check_expiry(&cert, 315_360_000),
            "expired cert should be detected as expiring"
        );
    }

    // --- Hostname ---

    #[test]
    fn hostname_exact_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "www.example.com"),
            "should match www.example.com"
        );
    }

    #[test]
    fn hostname_bare_domain_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "example.com"),
            "should match example.com (in SAN)"
        );
    }

    #[test]
    fn hostname_wildcard_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "sub.example.com"),
            "should match *.example.com wildcard"
        );
    }

    #[test]
    fn hostname_wildcard_does_not_match_deep_subdomain() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "deep.sub.example.com"),
            "wildcard should not match deep.sub.example.com"
        );
    }

    #[test]
    fn hostname_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "bad.example.org"),
            "should not match bad.example.org"
        );
    }

    #[test]
    fn hostname_case_insensitive() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "WWW.EXAMPLE.COM"),
            "hostname matching should be case-insensitive"
        );
    }

    // --- IP ---

    #[test]
    fn ip_v4_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "93.184.216.34"),
            "should match IPv4 93.184.216.34"
        );
    }

    #[test]
    fn ip_v4_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_ip(&cert, "1.2.3.4"),
            "should not match 1.2.3.4"
        );
    }

    #[test]
    fn ip_v6_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "2606:2800:220:1:248:1893:25c8:1946"),
            "should match IPv6 address"
        );
    }

    // --- Email ---

    #[test]
    fn email_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_email(&cert, "admin@example.com"),
            "should match admin@example.com"
        );
    }

    #[test]
    fn email_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_email(&cert, "nobody@bad.com"),
            "should not match nobody@bad.com"
        );
    }

    #[test]
    fn client_email_match() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_email(&cert, "client@example.com"),
            "should match client@example.com"
        );
    }
}

// =========================================================================
// 7. CONVERSION TESTS
// =========================================================================

mod conversion {
    use super::*;

    #[test]
    fn pem_to_der_conversion() {
        let pem_data = load_cert("root-ca.pem");
        let expected_der = load_cert("root-ca.der");
        let result = pem_to_der(&pem_data).expect("PEM to DER should succeed");
        assert_eq!(result, expected_der, "converted DER should match reference");
    }

    #[test]
    fn der_to_pem_conversion() {
        let der_data = load_cert("root-ca.der");
        let pem_str = der_to_pem(&der_data);
        assert!(
            pem_str.contains("BEGIN CERTIFICATE"),
            "should have PEM header"
        );
        assert!(
            pem_str.contains("END CERTIFICATE"),
            "should have PEM footer"
        );
    }

    #[test]
    fn pem_to_der_to_pem_roundtrip() {
        let original_pem = load_cert("server.pem");
        let der = pem_to_der(&original_pem).expect("PEM to DER should succeed");
        let pem_again = der_to_pem(&der);

        // The PEM might have different whitespace, so compare via DER
        let der_again = pem_to_der(pem_again.as_bytes()).expect("should parse regenerated PEM");
        assert_eq!(der, der_again, "roundtrip should preserve certificate");
    }

    #[test]
    fn der_to_pem_to_der_roundtrip() {
        let original_der = load_cert("server.der");
        let pem = der_to_pem(&original_der);
        let der_again = pem_to_der(pem.as_bytes()).expect("should parse generated PEM");
        assert_eq!(
            original_der, der_again,
            "roundtrip should preserve certificate"
        );
    }

    #[test]
    fn pem_to_der_invalid_input() {
        assert!(pem_to_der(b"not a pem").is_err());
    }
}

// =========================================================================
// 8. DISPLAY TESTS
// =========================================================================

mod display {
    use super::*;

    #[test]
    fn display_text_contains_subject() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("www.example.com"),
            "text output should contain subject CN"
        );
    }

    #[test]
    fn display_text_contains_issuer() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Test Intermediate CA"),
            "text output should contain issuer CN"
        );
    }

    #[test]
    fn display_text_contains_serial() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("1000") || text.contains("10:00"),
            "text output should contain serial number"
        );
    }

    #[test]
    fn display_text_contains_validity() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("2026") && text.contains("2101"),
            "text output should contain validity dates"
        );
    }

    #[test]
    fn display_text_contains_extensions() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Subject Alternative Name") || text.contains("SAN") || text.contains("subjectAltName"),
            "text output should mention SAN extension"
        );
    }

    #[test]
    fn display_text_contains_fingerprint() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Fingerprint") || text.contains("fingerprint"),
            "text output should contain fingerprint"
        );
    }

    #[test]
    fn display_text_all_includes_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, true);
        assert!(
            text.contains("Signature") || text.contains("signature"),
            "display_text with show_all should include signature"
        );
    }

    #[test]
    fn json_output_is_valid() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let json_str = to_json(&cert).expect("JSON serialization should succeed");
        let parsed: serde_json::Value =
            serde_json::from_str(&json_str).expect("output should be valid JSON");
        assert!(parsed.is_object(), "JSON root should be an object");
    }

    #[test]
    fn json_contains_expected_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let json_str = to_json(&cert).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();

        assert!(parsed.get("version").is_some(), "JSON should have version");
        assert!(parsed.get("serial").is_some(), "JSON should have serial");
        assert!(parsed.get("subject").is_some(), "JSON should have subject");
        assert!(parsed.get("issuer").is_some(), "JSON should have issuer");
        assert!(
            parsed.get("not_before").is_some(),
            "JSON should have not_before"
        );
        assert!(
            parsed.get("not_after").is_some(),
            "JSON should have not_after"
        );
        assert!(
            parsed.get("extensions").is_some(),
            "JSON should have extensions"
        );
    }
}

// =========================================================================
// 9. ALGORITHM-SPECIFIC TESTS
// =========================================================================

mod algorithms {
    use super::*;

    #[test]
    fn rsa_cert_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert!(cert.public_key.modulus.is_some());
        assert!(cert.public_key.curve.is_none());
    }

    #[test]
    fn ecdsa_p256_cert_fields() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-256")
                || cert.public_key.curve.as_deref() == Some("prime256v1"),
            "curve: {:?}",
            cert.public_key.curve
        );
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn ecdsa_p384_cert_fields() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-384")
                || cert.public_key.curve.as_deref() == Some("secp384r1"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ed25519_cert_fields() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn all_cert_types_produce_valid_fingerprints() {
        for name in &[
            "root-ca.pem",
            "server.pem",
            "client.pem",
            "ec-p256.pem",
            "ec-p384.pem",
            "ed25519.pem",
            "minimal.pem",
            "many-extensions.pem",
        ] {
            let data = load_cert(name);
            let cert = parse_cert(&data).unwrap();
            let fp = cert.fingerprint(DigestAlgorithm::Sha256);
            // SHA-256 = 32 bytes = 32*3-1 = 95 chars
            assert_eq!(
                fp.len(),
                95,
                "SHA-256 fingerprint for {} has wrong length: {} ({})",
                name,
                fp.len(),
                fp
            );
        }
    }
}
