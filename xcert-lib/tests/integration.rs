//! Integration tests for xcert-lib using generated test certificates.
//!
//! Test certificates are in tests/certs/ (generated by tests/certs/generate.sh).
//! Reference outputs from openssl x509 are in tests/certs/reference/.
//!
//! These tests exercise the library API against known-good certificates and
//! compare results to openssl x509 output where applicable.

use xcert_lib::*;

// ---------------------------------------------------------------------------
// Helper: load a test certificate file
// ---------------------------------------------------------------------------

fn cert_path(name: &str) -> std::path::PathBuf {
    let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.pop(); // up from xcert-lib to workspace root
    p.push("tests");
    p.push("certs");
    p.push(name);
    p
}

fn load_cert(name: &str) -> Vec<u8> {
    std::fs::read(cert_path(name)).unwrap_or_else(|e| {
        panic!(
            "Failed to read test certificate '{}': {}. Run tests/certs/generate.sh first.",
            name, e
        )
    })
}

fn load_reference(name: &str) -> String {
    let mut p = cert_path("reference");
    p.pop();
    p.push("reference");
    p.push(name);
    std::fs::read_to_string(&p).unwrap_or_else(|e| {
        panic!(
            "Failed to read reference file '{}': {}. Run tests/certs/generate.sh first.",
            name, e
        )
    })
}

// =========================================================================
// 1. PARSING TESTS
// =========================================================================

mod parsing {
    use super::*;

    #[test]
    fn parse_rsa_pem() {
        let data = load_cert("root-ca.pem");
        let cert = parse_pem(&data).expect("should parse root CA PEM");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_rsa_der() {
        let data = load_cert("root-ca.der");
        let cert = parse_der(&data).expect("should parse root CA DER");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_pem() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).expect("should auto-detect PEM and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_auto_detect_der() {
        let data = load_cert("server.der");
        let cert = parse_cert(&data).expect("should auto-detect DER and parse");
        assert_eq!(cert.version, 3);
    }

    #[test]
    fn parse_ec_p256() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).expect("should parse ECDSA P-256 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "EC");
    }

    #[test]
    fn parse_ec_p384() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).expect("should parse ECDSA P-384 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "EC");
    }

    #[test]
    fn parse_ed25519() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).expect("should parse Ed25519 cert");
        assert_eq!(cert.version, 3);
        assert_eq!(cert.public_key.algorithm, "Ed25519");
    }

    #[test]
    fn parse_minimal_self_signed() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).expect("should parse minimal cert");
        // Minimal cert created with -subj "/CN=Minimal Test"
        assert!(cert.subject_string().contains("Minimal Test"));
    }

    #[test]
    fn parse_expired_cert() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).expect("should parse expired cert");
        assert!(cert.subject_string().contains("Expired Test"));
    }

    #[test]
    fn parse_many_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).expect("should parse cert with many extensions");
        assert!(!cert.extensions.is_empty(), "should have extensions");
    }

    #[test]
    fn parse_utf8_subject() {
        let data = load_cert("utf8-subject.pem");
        let cert = parse_cert(&data).expect("should parse cert with UTF-8 subject");
        // Should contain French characters
        let subject = cert.subject_string();
        assert!(
            subject.contains("Paris") || subject.contains("France"),
            "UTF-8 subject should contain French location, got: {}",
            subject
        );
    }

    #[test]
    fn parse_chain_takes_first_cert() {
        let data = load_cert("chain.pem");
        let cert = parse_cert(&data).expect("should parse first cert in chain");
        // chain.pem = server + intermediate + root; first should be server
        assert!(cert.subject_string().contains("www.example.com"));
    }

    #[test]
    fn parse_invalid_data_returns_error() {
        let data = b"this is not a certificate";
        assert!(parse_cert(data).is_err());
    }

    #[test]
    fn parse_empty_input_returns_error() {
        assert!(parse_cert(b"").is_err());
    }

    #[test]
    fn parse_truncated_der_returns_error() {
        let data = load_cert("root-ca.der");
        let truncated = &data[..data.len() / 2];
        assert!(parse_der(truncated).is_err());
    }
}

// =========================================================================
// 2. FIELD EXTRACTION TESTS
// =========================================================================

mod fields {
    use super::*;

    // --- Subject ---

    #[test]
    fn root_ca_subject() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(subject.contains("Test Root CA"), "subject: {}", subject);
        assert!(subject.contains("US"), "subject should contain country");
        assert!(
            subject.contains("Test PKI"),
            "subject should contain org"
        );
    }

    #[test]
    fn server_subject() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("www.example.com"),
            "subject: {}",
            subject
        );
        assert!(
            subject.contains("Example Corp"),
            "subject should contain org"
        );
    }

    #[test]
    fn ec_p256_subject() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("ec-test.example.com"),
            "subject: {}",
            subject
        );
        assert!(subject.contains("DE"), "subject should contain country DE");
    }

    #[test]
    fn ed25519_subject() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        let subject = cert.subject_string();
        assert!(
            subject.contains("ed25519.example.com"),
            "subject: {}",
            subject
        );
    }

    // --- Issuer ---

    #[test]
    fn root_ca_is_self_signed() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(
            cert.subject_string(),
            cert.issuer_string(),
            "root CA should be self-signed"
        );
    }

    #[test]
    fn server_issuer_is_intermediate() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let issuer = cert.issuer_string();
        assert!(
            issuer.contains("Test Intermediate CA"),
            "issuer: {}",
            issuer
        );
    }

    #[test]
    fn intermediate_issuer_is_root() {
        let data = load_cert("intermediate-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let issuer = cert.issuer_string();
        assert!(issuer.contains("Test Root CA"), "issuer: {}", issuer);
    }

    // --- Serial ---

    #[test]
    fn root_ca_serial() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let serial = cert.serial_hex();
        // openssl reports serial=01
        assert!(
            serial == "01" || serial == "1",
            "root CA serial should be 01, got: {}",
            serial
        );
    }

    #[test]
    fn server_serial() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let serial = cert.serial_hex();
        // openssl reports serial=1000
        // Serial 0x1000 can be "10:00" (colon-separated) or "1000"
        let serial_stripped = serial.replace(":", "");
        assert!(
            serial_stripped.to_uppercase().contains("1000"),
            "server serial should contain 1000, got: {}",
            serial
        );
    }

    // --- Dates ---

    #[test]
    fn server_dates_are_reasonable() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // not_before should be in 2026
        assert!(
            cert.not_before_string().contains("2026"),
            "not_before: {}",
            cert.not_before_string()
        );
        // not_after should be in 2101 (75 year validity)
        assert!(
            cert.not_after_string().contains("2101"),
            "not_after: {}",
            cert.not_after_string()
        );
    }

    #[test]
    fn expired_cert_dates() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // The expired cert has 1-day validity
        let not_before = cert.not_before_string();
        let not_after = cert.not_after_string();
        assert!(!not_before.is_empty(), "not_before should not be empty");
        assert!(!not_after.is_empty(), "not_after should not be empty");
    }

    // --- Public Key Info ---

    #[test]
    fn server_rsa_2048_key() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
    }

    #[test]
    fn ec_p256_key_info() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(
            cert.public_key.curve.as_deref(),
            Some("P-256"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ec_p384_key_info() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert_eq!(
            cert.public_key.curve.as_deref(),
            Some("P-384"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ed25519_key_info() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "Ed25519");
    }

    #[test]
    fn rsa_modulus_present() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let modulus = cert.modulus_hex();
        assert!(modulus.is_some(), "RSA cert should have modulus");
        let modulus = modulus.unwrap();
        assert!(!modulus.is_empty(), "modulus should not be empty");
    }

    #[test]
    fn ec_has_no_modulus() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.modulus_hex().is_none(),
            "EC cert should not have modulus"
        );
    }

    #[test]
    fn public_key_pem_format() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let pem = cert.public_key_pem();
        assert!(
            pem.contains("BEGIN PUBLIC KEY"),
            "public key PEM should have header"
        );
        assert!(
            pem.contains("END PUBLIC KEY"),
            "public key PEM should have footer"
        );
    }

    // --- Signature Algorithm ---

    #[test]
    fn server_sha256_rsa_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha256")
                || cert.signature_algorithm.contains("SHA256")
                || cert.signature_algorithm.contains("sha256WithRSAEncryption"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }

    #[test]
    fn ec_p384_sha384_signature() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            cert.signature_algorithm.contains("sha384")
                || cert.signature_algorithm.contains("SHA384")
                || cert.signature_algorithm.contains("ecdsa-with-SHA384"),
            "sig alg: {}",
            cert.signature_algorithm
        );
    }
}

// =========================================================================
// 3. EXTENSION TESTS
// =========================================================================

mod extensions {
    use super::*;

    #[test]
    fn root_ca_is_ca() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "root CA should have BasicConstraints");
        if let Some(ext) = bc {
            assert!(ext.critical, "BasicConstraints should be critical on CA");
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(ca, "CA flag should be true");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn intermediate_ca_pathlen_zero() {
        let data = load_cert("intermediate-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "intermediate CA should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, path_len } => {
                    assert!(ca, "CA flag should be true");
                    assert_eq!(*path_len, Some(0), "pathlen should be 0");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_not_ca() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let bc = cert.extensions.iter().find(|e| e.name.contains("Basic"));
        assert!(bc.is_some(), "server should have BasicConstraints");
        if let Some(ext) = bc {
            match &ext.value {
                ExtensionValue::BasicConstraints { ca, .. } => {
                    assert!(!ca, "server CA flag should be false");
                }
                _ => panic!("unexpected extension value type"),
            }
        }
    }

    #[test]
    fn server_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "server should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter().any(|u| u.contains("Digital Signature") || u.contains("digitalSignature")),
            "should include Digital Signature, got: {:?}",
            ku
        );
        assert!(
            ku.iter().any(|u| u.contains("Key Encipherment") || u.contains("keyEncipherment")),
            "should include Key Encipherment, got: {:?}",
            ku
        );
    }

    #[test]
    fn server_extended_key_usage() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "server should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter().any(|u| u.contains("Server") || u.contains("serverAuth")),
            "should include serverAuth, got: {:?}",
            eku
        );
    }

    #[test]
    fn client_extended_key_usage() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some(), "client should have ExtendedKeyUsage");
        let eku = eku.unwrap();
        assert!(
            eku.iter().any(|u| u.contains("Client") || u.contains("clientAuth")),
            "should include clientAuth, got: {:?}",
            eku
        );
        assert!(
            eku.iter().any(|u| u.contains("mail") || u.contains("emailProtection")),
            "should include emailProtection, got: {:?}",
            eku
        );
    }

    #[test]
    fn server_san_dns_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        assert!(!san.is_empty(), "server should have SAN entries");

        let dns_names: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Dns(name) => Some(name.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            dns_names.contains(&"www.example.com"),
            "should contain www.example.com, got: {:?}",
            dns_names
        );
        assert!(
            dns_names.contains(&"example.com"),
            "should contain example.com"
        );
        assert!(
            dns_names.contains(&"*.example.com"),
            "should contain *.example.com"
        );
    }

    #[test]
    fn server_san_ip_entries() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let ips: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Ip(ip) => Some(ip.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            ips.iter().any(|ip| ip.contains("93.184.216.34")),
            "should contain IPv4 93.184.216.34, got: {:?}",
            ips
        );
        // IPv6 address
        assert!(
            ips.iter().any(|ip| ip.to_lowercase().contains("2606:2800")),
            "should contain IPv6 address, got: {:?}",
            ips
        );
    }

    #[test]
    fn server_san_email_entry() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let emails: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Email(email) => Some(email.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            emails.contains(&"admin@example.com"),
            "should contain admin@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn server_authority_info_access() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let ocsp_urls = cert.ocsp_urls();
        assert!(
            ocsp_urls.iter().any(|u| u.contains("ocsp.example.com")),
            "should have OCSP URL, got: {:?}",
            ocsp_urls
        );
    }

    #[test]
    fn many_extensions_cert_has_expected_extensions() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();

        let ext_names: Vec<&str> = cert.extensions.iter().map(|e| e.name.as_str()).collect();

        // Should have at least: BasicConstraints, KeyUsage, ExtendedKeyUsage, SKI, AKI, SAN, AIA, CRL DP
        assert!(
            ext_names.iter().any(|n| n.contains("Basic")),
            "should have BasicConstraints"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Key Usage") && !n.contains("Extended")),
            "should have KeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Extended")),
            "should have ExtendedKeyUsage"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Subject Alternative")),
            "should have SubjectAltName"
        );
        assert!(
            ext_names.iter().any(|n| n.contains("Authority Information")),
            "should have AuthorityInfoAccess"
        );
    }

    #[test]
    fn many_extensions_eku_values() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let eku = cert.ext_key_usage();
        assert!(eku.is_some());
        let eku = eku.unwrap();
        // Should include: serverAuth, clientAuth, codeSigning, emailProtection, timeStamping
        assert!(
            eku.len() >= 5,
            "should have at least 5 EKU values, got {} : {:?}",
            eku.len(),
            eku
        );
    }

    #[test]
    fn many_extensions_san_has_uri() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();

        let uris: Vec<&str> = san
            .iter()
            .filter_map(|e| match e {
                SanEntry::Uri(u) => Some(u.as_str()),
                _ => None,
            })
            .collect();

        assert!(
            uris.iter().any(|u| u.contains("example.com/cert-info")),
            "should contain URI SAN, got: {:?}",
            uris
        );
    }

    #[test]
    fn root_ca_key_usage_includes_cert_sign() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let ku = cert.key_usage();
        assert!(ku.is_some(), "root CA should have KeyUsage");
        let ku = ku.unwrap();
        assert!(
            ku.iter().any(|u| u.contains("Cert Sign") || u.contains("keyCertSign") || u.contains("Certificate Sign")),
            "root CA should have keyCertSign, got: {:?}",
            ku
        );
    }

    #[test]
    fn minimal_cert_has_no_san() {
        let data = load_cert("minimal.pem");
        let cert = parse_cert(&data).unwrap();
        let san = cert.san_entries();
        // A minimal self-signed cert may or may not have SAN depending on openssl defaults
        // But our explicitly minimal cert should have minimal extensions
        // This is a structural test -- we mainly verify it doesn't crash
        let _ = san;
    }
}

// =========================================================================
// 4. FINGERPRINT TESTS
// =========================================================================

mod fingerprints {
    use super::*;

    #[test]
    fn root_ca_sha256_fingerprint() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        assert_eq!(
            fp.to_uppercase(),
            "B3:33:1D:8E:18:2E:E1:27:6A:4E:E1:B7:A8:A6:E0:1D:47:54:38:4F:B1:E4:79:C7:F3:95:4B:6F:F1:B3:E4:A2",
            "SHA-256 fingerprint mismatch"
        );
    }

    #[test]
    fn root_ca_sha1_fingerprint() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha1);
        assert_eq!(
            fp.to_uppercase(),
            "C6:98:03:8E:D0:B6:9C:25:B1:15:32:B8:BA:0B:72:FC:62:C3:86:60",
            "SHA-1 fingerprint mismatch"
        );
    }

    #[test]
    fn server_sha256_fingerprint() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        assert_eq!(
            fp.to_uppercase(),
            "ED:D7:70:25:25:CC:22:0C:62:0D:FA:CD:96:DE:9E:AE:83:32:9A:AD:D7:70:BB:43:DF:F7:70:93:52:94:7E:C7",
            "SHA-256 fingerprint mismatch"
        );
    }

    #[test]
    fn many_extensions_sha256_fingerprint() {
        let data = load_cert("many-extensions.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha256);
        assert_eq!(
            fp.to_uppercase(),
            "23:D7:85:CF:FF:CF:EC:48:D2:FF:51:26:AE:06:80:53:BD:6E:7F:0D:A1:0E:D4:57:EF:9B:86:28:AF:9D:BC:40",
            "SHA-256 fingerprint mismatch"
        );
    }

    #[test]
    fn fingerprint_from_pem_matches_der() {
        let pem_data = load_cert("root-ca.pem");
        let der_data = load_cert("root-ca.der");
        let pem_cert = parse_pem(&pem_data).unwrap();
        let der_cert = parse_der(&der_data).unwrap();
        assert_eq!(
            pem_cert.fingerprint(DigestAlgorithm::Sha256),
            der_cert.fingerprint(DigestAlgorithm::Sha256),
            "PEM and DER should produce the same fingerprint"
        );
    }

    #[test]
    fn sha384_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha384);
        // SHA-384 = 48 bytes = 48*3-1 = 143 chars in colon-separated hex
        assert_eq!(fp.len(), 143, "SHA-384 fingerprint wrong length: {}", fp);
    }

    #[test]
    fn sha512_fingerprint_is_correct_length() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let fp = cert.fingerprint(DigestAlgorithm::Sha512);
        // SHA-512 = 64 bytes = 64*3-1 = 191 chars in colon-separated hex
        assert_eq!(fp.len(), 191, "SHA-512 fingerprint wrong length: {}", fp);
    }
}

// =========================================================================
// 5. EMAIL EXTRACTION TESTS
// =========================================================================

mod emails {
    use super::*;

    #[test]
    fn server_emails() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(
            emails.contains(&"admin@example.com".to_string()),
            "should contain admin@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn client_emails() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(
            emails.contains(&"client@example.com".to_string()),
            "should contain client@example.com, got: {:?}",
            emails
        );
    }

    #[test]
    fn root_ca_no_emails() {
        let data = load_cert("root-ca.pem");
        let cert = parse_cert(&data).unwrap();
        let emails = cert.emails();
        assert!(emails.is_empty(), "root CA should have no emails");
    }
}

// =========================================================================
// 6. CHECK TESTS
// =========================================================================

mod checks {
    use super::*;

    // --- Expiry ---

    #[test]
    fn server_not_expired() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        // Server cert valid until 2101; checking with 0 seconds means "is it valid now?"
        assert!(
            check_expiry(&cert, 0),
            "server cert should not be expired"
        );
    }

    #[test]
    fn server_valid_for_one_year() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_expiry(&cert, 365 * 24 * 60 * 60),
            "server cert should be valid for at least 1 year"
        );
    }

    #[test]
    fn expired_cert_is_expired() {
        let data = load_cert("expired.pem");
        let cert = parse_cert(&data).unwrap();
        // Check if it expires within 10 years (it already has since it was 1-day)
        assert!(
            !check_expiry(&cert, 315_360_000),
            "expired cert should be detected as expiring"
        );
    }

    // --- Hostname ---

    #[test]
    fn hostname_exact_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "www.example.com"),
            "should match www.example.com"
        );
    }

    #[test]
    fn hostname_bare_domain_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "example.com"),
            "should match example.com (in SAN)"
        );
    }

    #[test]
    fn hostname_wildcard_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "sub.example.com"),
            "should match *.example.com wildcard"
        );
    }

    #[test]
    fn hostname_wildcard_does_not_match_deep_subdomain() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "deep.sub.example.com"),
            "wildcard should not match deep.sub.example.com"
        );
    }

    #[test]
    fn hostname_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_host(&cert, "bad.example.org"),
            "should not match bad.example.org"
        );
    }

    #[test]
    fn hostname_case_insensitive() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_host(&cert, "WWW.EXAMPLE.COM"),
            "hostname matching should be case-insensitive"
        );
    }

    // --- IP ---

    #[test]
    fn ip_v4_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "93.184.216.34"),
            "should match IPv4 93.184.216.34"
        );
    }

    #[test]
    fn ip_v4_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_ip(&cert, "1.2.3.4"),
            "should not match 1.2.3.4"
        );
    }

    #[test]
    fn ip_v6_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_ip(&cert, "2606:2800:220:1:248:1893:25c8:1946"),
            "should match IPv6 address"
        );
    }

    // --- Email ---

    #[test]
    fn email_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_email(&cert, "admin@example.com"),
            "should match admin@example.com"
        );
    }

    #[test]
    fn email_no_match() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            !check_email(&cert, "nobody@bad.com"),
            "should not match nobody@bad.com"
        );
    }

    #[test]
    fn client_email_match() {
        let data = load_cert("client.pem");
        let cert = parse_cert(&data).unwrap();
        assert!(
            check_email(&cert, "client@example.com"),
            "should match client@example.com"
        );
    }
}

// =========================================================================
// 7. CONVERSION TESTS
// =========================================================================

mod conversion {
    use super::*;

    #[test]
    fn pem_to_der_conversion() {
        let pem_data = load_cert("root-ca.pem");
        let expected_der = load_cert("root-ca.der");
        let result = pem_to_der(&pem_data).expect("PEM to DER should succeed");
        assert_eq!(result, expected_der, "converted DER should match reference");
    }

    #[test]
    fn der_to_pem_conversion() {
        let der_data = load_cert("root-ca.der");
        let pem_str = der_to_pem(&der_data);
        assert!(
            pem_str.contains("BEGIN CERTIFICATE"),
            "should have PEM header"
        );
        assert!(
            pem_str.contains("END CERTIFICATE"),
            "should have PEM footer"
        );
    }

    #[test]
    fn pem_to_der_to_pem_roundtrip() {
        let original_pem = load_cert("server.pem");
        let der = pem_to_der(&original_pem).expect("PEM to DER should succeed");
        let pem_again = der_to_pem(&der);

        // The PEM might have different whitespace, so compare via DER
        let der_again = pem_to_der(pem_again.as_bytes()).expect("should parse regenerated PEM");
        assert_eq!(der, der_again, "roundtrip should preserve certificate");
    }

    #[test]
    fn der_to_pem_to_der_roundtrip() {
        let original_der = load_cert("server.der");
        let pem = der_to_pem(&original_der);
        let der_again = pem_to_der(pem.as_bytes()).expect("should parse generated PEM");
        assert_eq!(
            original_der, der_again,
            "roundtrip should preserve certificate"
        );
    }

    #[test]
    fn pem_to_der_invalid_input() {
        assert!(pem_to_der(b"not a pem").is_err());
    }
}

// =========================================================================
// 8. DISPLAY TESTS
// =========================================================================

mod display {
    use super::*;

    #[test]
    fn display_text_contains_subject() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("www.example.com"),
            "text output should contain subject CN"
        );
    }

    #[test]
    fn display_text_contains_issuer() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Test Intermediate CA"),
            "text output should contain issuer CN"
        );
    }

    #[test]
    fn display_text_contains_serial() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("1000") || text.contains("10:00"),
            "text output should contain serial number"
        );
    }

    #[test]
    fn display_text_contains_validity() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("2026") && text.contains("2101"),
            "text output should contain validity dates"
        );
    }

    #[test]
    fn display_text_contains_extensions() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Subject Alternative Name") || text.contains("SAN") || text.contains("subjectAltName"),
            "text output should mention SAN extension"
        );
    }

    #[test]
    fn display_text_contains_fingerprint() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, false);
        assert!(
            text.contains("Fingerprint") || text.contains("fingerprint"),
            "text output should contain fingerprint"
        );
    }

    #[test]
    fn display_text_all_includes_signature() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let text = display_text(&cert, true);
        assert!(
            text.contains("Signature") || text.contains("signature"),
            "display_text with show_all should include signature"
        );
    }

    #[test]
    fn json_output_is_valid() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let json_str = to_json(&cert).expect("JSON serialization should succeed");
        let parsed: serde_json::Value =
            serde_json::from_str(&json_str).expect("output should be valid JSON");
        assert!(parsed.is_object(), "JSON root should be an object");
    }

    #[test]
    fn json_contains_expected_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        let json_str = to_json(&cert).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();

        assert!(parsed.get("version").is_some(), "JSON should have version");
        assert!(parsed.get("serial").is_some(), "JSON should have serial");
        assert!(parsed.get("subject").is_some(), "JSON should have subject");
        assert!(parsed.get("issuer").is_some(), "JSON should have issuer");
        assert!(
            parsed.get("not_before").is_some(),
            "JSON should have not_before"
        );
        assert!(
            parsed.get("not_after").is_some(),
            "JSON should have not_after"
        );
        assert!(
            parsed.get("extensions").is_some(),
            "JSON should have extensions"
        );
    }
}

// =========================================================================
// 9. ALGORITHM-SPECIFIC TESTS
// =========================================================================

mod algorithms {
    use super::*;

    #[test]
    fn rsa_cert_fields() {
        let data = load_cert("server.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "RSA");
        assert_eq!(cert.public_key.key_size, Some(2048));
        assert!(cert.public_key.modulus.is_some());
        assert!(cert.public_key.curve.is_none());
    }

    #[test]
    fn ecdsa_p256_cert_fields() {
        let data = load_cert("ec-p256.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-256")
                || cert.public_key.curve.as_deref() == Some("prime256v1"),
            "curve: {:?}",
            cert.public_key.curve
        );
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn ecdsa_p384_cert_fields() {
        let data = load_cert("ec-p384.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "EC");
        assert!(
            cert.public_key.curve.as_deref() == Some("P-384")
                || cert.public_key.curve.as_deref() == Some("secp384r1"),
            "curve: {:?}",
            cert.public_key.curve
        );
    }

    #[test]
    fn ed25519_cert_fields() {
        let data = load_cert("ed25519.pem");
        let cert = parse_cert(&data).unwrap();
        assert_eq!(cert.public_key.algorithm, "Ed25519");
        assert!(cert.public_key.modulus.is_none());
    }

    #[test]
    fn all_cert_types_produce_valid_fingerprints() {
        for name in &[
            "root-ca.pem",
            "server.pem",
            "client.pem",
            "ec-p256.pem",
            "ec-p384.pem",
            "ed25519.pem",
            "minimal.pem",
            "many-extensions.pem",
        ] {
            let data = load_cert(name);
            let cert = parse_cert(&data).unwrap();
            let fp = cert.fingerprint(DigestAlgorithm::Sha256);
            // SHA-256 = 32 bytes = 32*3-1 = 95 chars
            assert_eq!(
                fp.len(),
                95,
                "SHA-256 fingerprint for {} has wrong length: {} ({})",
                name,
                fp.len(),
                fp
            );
        }
    }
}

// =========================================================================
// 10. DEGENERATE / MALFORMED INPUT TESTS
// =========================================================================
//
// These test vectors exercise edge cases and error-handling paths in the
// parser.  Each test asserts that the library returns an error (or, where
// noted, succeeds gracefully) without panicking or hanging.

mod degenerate {
    use super::*;

    /// Helper: build a path under tests/certs/degenerate/
    fn degen_path(name: &str) -> std::path::PathBuf {
        let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        p.pop(); // up from xcert-lib to workspace root
        p.push("tests");
        p.push("certs");
        p.push("degenerate");
        p.push(name);
        p
    }

    fn load_degen(name: &str) -> Vec<u8> {
        std::fs::read(degen_path(name)).unwrap_or_else(|e| {
            panic!(
                "Failed to read degenerate test file '{}': {}",
                name, e
            )
        })
    }

    // -----------------------------------------------------------------
    // 1. empty.der -- 0-byte file
    // -----------------------------------------------------------------
    #[test]
    fn empty_file_returns_error() {
        let data = load_degen("empty.der");
        assert!(data.is_empty());
        let result = parse_cert(&data);
        assert!(result.is_err(), "empty input must return an error");
    }

    #[test]
    fn empty_file_der_returns_error() {
        let data = load_degen("empty.der");
        let result = parse_der(&data);
        assert!(result.is_err(), "empty DER input must return an error");
    }

    // -----------------------------------------------------------------
    // 2. one-byte.der -- single SEQUENCE tag, no length or body
    // -----------------------------------------------------------------
    #[test]
    fn one_byte_returns_error() {
        let data = load_degen("one-byte.der");
        assert_eq!(data.len(), 1);
        assert_eq!(data[0], 0x30, "should be a SEQUENCE tag");
        let result = parse_der(&data);
        assert!(result.is_err(), "single byte must return an error");
    }

    #[test]
    fn one_byte_auto_detect_returns_error() {
        let data = load_degen("one-byte.der");
        let result = parse_cert(&data);
        assert!(result.is_err(), "single byte via parse_cert must return an error");
    }

    // -----------------------------------------------------------------
    // 3. truncated-header.der -- first 10 bytes of a valid DER cert
    // -----------------------------------------------------------------
    #[test]
    fn truncated_header_returns_error() {
        let data = load_degen("truncated-header.der");
        assert_eq!(data.len(), 10);
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "truncated header (10 bytes) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 4. truncated-body.der -- first half of a valid DER cert
    // -----------------------------------------------------------------
    #[test]
    fn truncated_body_returns_error() {
        let data = load_degen("truncated-body.der");
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "truncated body (half cert) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 5. random-bytes.der -- 1024 random bytes
    // -----------------------------------------------------------------
    #[test]
    fn random_bytes_returns_error() {
        let data = load_degen("random-bytes.der");
        assert_eq!(data.len(), 1024);
        let result = parse_der(&data);
        assert!(result.is_err(), "random bytes must return an error");
    }

    #[test]
    fn random_bytes_auto_detect_returns_error() {
        let data = load_degen("random-bytes.der");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "random bytes via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 6. wrong-pem-label.pem -- valid base64 but "BEGIN RSA PRIVATE KEY"
    // -----------------------------------------------------------------
    #[test]
    fn wrong_pem_label_returns_error() {
        let data = load_degen("wrong-pem-label.pem");
        let result = parse_pem(&data);
        assert!(
            result.is_err(),
            "PEM with RSA PRIVATE KEY label must return an error"
        );
    }

    #[test]
    fn wrong_pem_label_auto_detect_returns_error() {
        let data = load_degen("wrong-pem-label.pem");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "wrong PEM label via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 7. corrupt-base64.pem -- PEM headers with invalid base64 body
    // -----------------------------------------------------------------
    #[test]
    fn corrupt_base64_returns_error() {
        let data = load_degen("corrupt-base64.pem");
        let result = parse_pem(&data);
        assert!(
            result.is_err(),
            "corrupt base64 PEM must return an error"
        );
    }

    #[test]
    fn corrupt_base64_auto_detect_returns_error() {
        let data = load_degen("corrupt-base64.pem");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "corrupt base64 via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 8. null-bytes.der -- 1024 null bytes
    // -----------------------------------------------------------------
    #[test]
    fn null_bytes_returns_error() {
        let data = load_degen("null-bytes.der");
        assert_eq!(data.len(), 1024);
        assert!(data.iter().all(|&b| b == 0));
        let result = parse_der(&data);
        assert!(result.is_err(), "1024 null bytes must return an error");
    }

    #[test]
    fn null_bytes_auto_detect_returns_error() {
        let data = load_degen("null-bytes.der");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "null bytes via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 9. huge-length.der -- SEQUENCE claiming 2GB, only 100 bytes of data
    // -----------------------------------------------------------------
    #[test]
    fn huge_length_returns_error() {
        let data = load_degen("huge-length.der");
        assert_eq!(data.len(), 106, "header(6) + filler(100)");
        // Must not hang or allocate 2GB; must return an error promptly
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "DER with huge claimed length must return an error"
        );
    }

    #[test]
    fn huge_length_auto_detect_returns_error() {
        let data = load_degen("huge-length.der");
        let result = parse_cert(&data);
        assert!(
            result.is_err(),
            "huge length via parse_cert must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 10. nested-sequence.der -- 100 levels of nested SEQUENCE
    // -----------------------------------------------------------------
    #[test]
    fn nested_sequence_returns_error() {
        let data = load_degen("nested-sequence.der");
        // This is valid DER structurally (nested SEQUENCEs) but is
        // not a valid certificate.  The parser must return an error
        // without stack-overflowing.
        let result = parse_der(&data);
        assert!(
            result.is_err(),
            "deeply nested SEQUENCEs (not a cert) must return an error"
        );
    }

    // -----------------------------------------------------------------
    // 11. negative-serial.der -- certificate with tweaked negative serial
    // -----------------------------------------------------------------
    #[test]
    fn negative_serial_parses_or_errors_gracefully() {
        let data = load_degen("negative-serial.der");
        // A real-world parser might accept or reject a negative serial.
        // The important thing is it must not panic.
        let result = parse_der(&data);
        // If it succeeds, the serial should be non-empty.
        // If it fails, the error must be an Err, not a panic.
        match result {
            Ok(cert) => {
                let serial = cert.serial_hex();
                assert!(
                    !serial.is_empty(),
                    "if parsed, serial should be non-empty"
                );
            }
            Err(_) => {
                // Returning an error is also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // 12. trailing-garbage.pem -- valid PEM cert + 1KB garbage appended
    // -----------------------------------------------------------------
    #[test]
    fn trailing_garbage_parses_first_cert() {
        let data = load_degen("trailing-garbage.pem");
        // The PEM parser should extract the first valid certificate
        // and ignore trailing garbage after the END marker.
        let result = parse_pem(&data);
        // Depending on the PEM parser, this may succeed (ignoring
        // trailing bytes) or fail.  Either is acceptable; no panic.
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
                assert!(cert.subject_string().contains("Test Root CA"));
            }
            Err(_) => {
                // Returning an error for trailing garbage is also fine
            }
        }
    }

    #[test]
    fn trailing_garbage_auto_detect() {
        let data = load_degen("trailing-garbage.pem");
        let result = parse_cert(&data);
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
            }
            Err(_) => {
                // Also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // 13. multiple-pem.pem -- cert + private key block + cert
    // -----------------------------------------------------------------
    #[test]
    fn multiple_pem_parses_first_cert() {
        let data = load_degen("multiple-pem.pem");
        // parse_pem should take the first PEM block it finds.
        // If the first block is a CERTIFICATE, it should succeed.
        let result = parse_pem(&data);
        match result {
            Ok(cert) => {
                // First block is root-ca.pem
                assert_eq!(cert.version, 3);
                assert!(
                    cert.subject_string().contains("Test Root CA"),
                    "should parse the first cert (root CA)"
                );
            }
            Err(e) => {
                // If the parser rejects mixed PEM, that is acceptable
                // as long as it does not panic
                let _ = e;
            }
        }
    }

    #[test]
    fn multiple_pem_auto_detect() {
        let data = load_degen("multiple-pem.pem");
        let result = parse_cert(&data);
        match result {
            Ok(cert) => {
                assert_eq!(cert.version, 3);
            }
            Err(_) => {
                // Also acceptable
            }
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken inputs should panic parse_cert
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_input() {
        let files = [
            "empty.der",
            "one-byte.der",
            "truncated-header.der",
            "truncated-body.der",
            "random-bytes.der",
            "wrong-pem-label.pem",
            "corrupt-base64.pem",
            "null-bytes.der",
            "huge-length.der",
            "nested-sequence.der",
            "negative-serial.der",
            "trailing-garbage.pem",
            "multiple-pem.pem",
        ];
        for name in &files {
            let data = load_degen(name);
            // Must not panic.  We use catch_unwind to turn panics
            // into failures with a clear message.
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_cert(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_cert panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken DER inputs should panic
    // parse_der
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_der_input() {
        let files = [
            "empty.der",
            "one-byte.der",
            "truncated-header.der",
            "truncated-body.der",
            "random-bytes.der",
            "null-bytes.der",
            "huge-length.der",
            "nested-sequence.der",
            "negative-serial.der",
        ];
        for name in &files {
            let data = load_degen(name);
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_der(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_der panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: none of the broken PEM inputs should panic
    // parse_pem
    // -----------------------------------------------------------------
    #[test]
    fn no_panics_on_any_degenerate_pem_input() {
        let files = [
            "wrong-pem-label.pem",
            "corrupt-base64.pem",
            "trailing-garbage.pem",
            "multiple-pem.pem",
        ];
        for name in &files {
            let data = load_degen(name);
            let data_clone = data.clone();
            let result = std::panic::catch_unwind(move || {
                let _ = parse_pem(&data_clone);
            });
            assert!(
                result.is_ok(),
                "parse_pem panicked on degenerate input: {}",
                name
            );
        }
    }

    // -----------------------------------------------------------------
    // Cross-cutting: pem_to_der should also handle broken PEM inputs
    // -----------------------------------------------------------------
    #[test]
    fn pem_to_der_rejects_corrupt_base64() {
        let data = load_degen("corrupt-base64.pem");
        let result = pem_to_der(&data);
        assert!(
            result.is_err(),
            "pem_to_der must reject corrupt base64"
        );
    }

    #[test]
    fn pem_to_der_rejects_wrong_label() {
        let data = load_degen("wrong-pem-label.pem");
        // pem_to_der extracts bytes regardless of label (it uses
        // x509_parser::pem which may or may not check).  Either
        // success or error is fine; must not panic.
        let _ = pem_to_der(&data);
    }
}

// =========================================================================
// 10. CERTIFICATE CHAIN VERIFICATION TESTS
// =========================================================================

mod verification {
    use super::*;

    fn real_cert_path(name: &str) -> std::path::PathBuf {
        let mut p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        p.pop();
        p.push("tests");
        p.push("certs");
        p.push("real");
        p.push(name);
        p
    }

    fn load_real_cert(name: &str) -> Vec<u8> {
        std::fs::read(real_cert_path(name)).unwrap_or_else(|e| {
            panic!("Failed to read real cert '{}': {}", name, e)
        })
    }

    fn test_trust_store() -> TrustStore {
        let root_pem = load_real_cert("test-root-ca.pem");
        TrustStore::from_pem(&root_pem).expect("failed to create trust store from test root CA")
    }

    fn ec_trust_store() -> TrustStore {
        let root_pem = load_real_cert("test-ec-root-ca.pem");
        TrustStore::from_pem(&root_pem).expect("failed to create trust store from EC root CA")
    }

    // -----------------------------------------------------------------------
    // PEM chain parsing
    // -----------------------------------------------------------------------

    #[test]
    fn parse_pem_chain_single_cert() {
        let data = load_real_cert("test-root-ca.pem");
        let chain = parse_pem_chain(&data).expect("failed to parse single cert");
        assert_eq!(chain.len(), 1);
    }

    #[test]
    fn parse_pem_chain_full_chain() {
        let data = load_real_cert("test-fullchain.pem");
        let chain = parse_pem_chain(&data).expect("failed to parse full chain");
        assert_eq!(chain.len(), 3, "full chain should have 3 certs: leaf + intermediate + root");
    }

    #[test]
    fn parse_pem_chain_two_certs() {
        // server.pem + intermediate-ca.pem
        let server = load_real_cert("test-server.pem");
        let intermediate = load_real_cert("test-intermediate-ca.pem");
        let mut combined = server;
        combined.extend_from_slice(&intermediate);
        let chain = parse_pem_chain(&combined).expect("failed to parse two-cert chain");
        assert_eq!(chain.len(), 2);
    }

    #[test]
    fn parse_pem_chain_empty_input() {
        let result = parse_pem_chain(b"");
        assert!(result.is_err(), "empty input should fail");
    }

    #[test]
    fn parse_pem_chain_no_certs() {
        let result = parse_pem_chain(b"not a cert");
        assert!(result.is_err(), "non-cert input should fail");
    }

    // -----------------------------------------------------------------------
    // Trust store
    // -----------------------------------------------------------------------

    #[test]
    fn trust_store_new_is_empty() {
        let store = TrustStore::new();
        assert!(store.is_empty());
        assert_eq!(store.len(), 0);
    }

    #[test]
    fn trust_store_from_pem_single_cert() {
        let store = test_trust_store();
        assert_eq!(store.len(), 1);
        assert!(!store.is_empty());
    }

    #[test]
    fn trust_store_from_pem_bundle() {
        let data = load_real_cert("test-fullchain.pem");
        let store = TrustStore::from_pem(&data).expect("failed to load bundle");
        assert_eq!(store.len(), 3, "bundle with 3 certs should load 3 entries");
    }

    #[test]
    fn trust_store_contains_added_cert() {
        let root_pem = load_real_cert("test-root-ca.pem");
        let chain = parse_pem_chain(&root_pem).expect("parse root");
        let store = test_trust_store();
        assert!(store.contains(&chain[0]), "trust store should contain the root cert");
    }

    #[test]
    fn trust_store_does_not_contain_unknown_cert() {
        let server_pem = load_real_cert("test-server.pem");
        let chain = parse_pem_chain(&server_pem).expect("parse server");
        let store = test_trust_store();
        assert!(!store.contains(&chain[0]), "trust store should not contain server cert");
    }

    #[test]
    fn trust_store_system_loads() {
        let store = TrustStore::system().expect("system trust store should load");
        assert!(store.len() > 50, "system store should have many CA certs, got {}", store.len());
    }

    // -----------------------------------------------------------------------
    // Chain verification - valid chains
    // -----------------------------------------------------------------------

    #[test]
    fn verify_valid_full_chain() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error");
        assert!(result.is_valid, "valid full chain should verify: {:?}", result.errors);
        assert_eq!(result.chain.len(), 3);
        assert_eq!(result.errors.len(), 0);
    }

    #[test]
    fn verify_chain_without_root_uses_trust_store() {
        // Chain is leaf + intermediate; root should come from trust store
        let server = load_real_cert("test-server.pem");
        let intermediate = load_real_cert("test-intermediate-ca.pem");
        let mut chain_pem = server;
        chain_pem.extend_from_slice(&intermediate);

        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error");
        assert!(result.is_valid, "chain without root should verify using trust store: {:?}", result.errors);
        // Chain info should include root from trust store
        assert_eq!(result.chain.len(), 3, "chain should be extended with root from trust store");
    }

    #[test]
    fn verify_valid_chain_with_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("www.example.com"))
            .expect("verification should not error");
        assert!(result.is_valid, "hostname www.example.com should match: {:?}", result.errors);
    }

    #[test]
    fn verify_valid_chain_with_san_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("example.com"))
            .expect("verification should not error");
        assert!(result.is_valid, "hostname example.com should match SAN: {:?}", result.errors);
    }

    #[test]
    fn verify_valid_chain_with_wildcard_hostname() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("sub.example.com"))
            .expect("verification should not error");
        assert!(result.is_valid, "wildcard *.example.com should match sub.example.com: {:?}", result.errors);
    }

    #[test]
    fn verify_ec_chain() {
        let chain_pem = load_real_cert("test-ec-fullchain.pem");
        let store = ec_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error");
        assert!(result.is_valid, "EC chain should verify: {:?}", result.errors);
        assert_eq!(result.chain.len(), 2);
    }

    #[test]
    fn verify_ec_chain_with_hostname() {
        let chain_pem = load_real_cert("test-ec-fullchain.pem");
        let store = ec_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("ec.example.com"))
            .expect("verification should not error");
        assert!(result.is_valid, "EC cert hostname should match: {:?}", result.errors);
    }

    #[test]
    fn verify_self_signed_root_in_trust_store() {
        let root_pem = load_real_cert("test-root-ca.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&root_pem, &store, None)
            .expect("verification should not error");
        assert!(result.is_valid, "self-signed root in trust store should verify: {:?}", result.errors);
    }

    // -----------------------------------------------------------------------
    // Chain verification - invalid chains
    // -----------------------------------------------------------------------

    #[test]
    fn verify_wrong_chain_fails_signature() {
        let chain_pem = load_real_cert("test-wrong-chain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error (just return invalid)");
        assert!(!result.is_valid, "wrong chain should not verify");
        assert!(
            result.errors.iter().any(|e| e.contains("signature verification failed")),
            "should report signature failure: {:?}", result.errors
        );
    }

    #[test]
    fn verify_untrusted_root_fails() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        // Use a different root as trust store - the chain's root won't be in it
        let store = ec_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error");
        assert!(!result.is_valid, "chain with untrusted root should fail");
        assert!(
            result.errors.iter().any(|e| e.contains("not in the trust store")),
            "should report untrusted root: {:?}", result.errors
        );
    }

    #[test]
    fn verify_wrong_hostname_fails() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, Some("wrong.example.org"))
            .expect("verification should not error");
        assert!(!result.is_valid, "wrong hostname should fail");
        assert!(
            result.errors.iter().any(|e| e.contains("hostname") && e.contains("wrong.example.org")),
            "should report hostname mismatch: {:?}", result.errors
        );
    }

    #[test]
    fn verify_deep_wildcard_does_not_match() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        // *.example.com should NOT match deep.sub.example.com
        let result = verify_pem_chain(&chain_pem, &store, Some("deep.sub.example.com"))
            .expect("verification should not error");
        assert!(!result.is_valid, "deep subdomain should not match wildcard");
    }

    #[test]
    fn verify_self_signed_not_in_trust_store_fails() {
        let root_pem = load_real_cert("test-root-ca.pem");
        // Use EC trust store (doesn't contain RSA root)
        let store = ec_trust_store();
        let result = verify_pem_chain(&root_pem, &store, None)
            .expect("verification should not error");
        assert!(!result.is_valid, "self-signed cert not in trust store should fail");
    }

    #[test]
    fn verify_empty_chain_errors() {
        let store = test_trust_store();
        let result = verify_chain(&[], &store, None);
        assert!(result.is_err(), "empty chain should be an error");
    }

    #[test]
    fn verify_chain_missing_intermediate() {
        // Just the leaf, no intermediate - root can't verify it directly
        let server_pem = load_real_cert("test-server.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&server_pem, &store, None)
            .expect("verification should not error");
        assert!(!result.is_valid, "leaf without intermediate should fail verification");
    }

    // -----------------------------------------------------------------------
    // Chain verification with DER input
    // -----------------------------------------------------------------------

    #[test]
    fn verify_chain_from_der() {
        let fullchain_pem = load_real_cert("test-fullchain.pem");
        let chain_der = parse_pem_chain(&fullchain_pem).expect("parse PEM chain");
        let store = test_trust_store();
        let result = verify_chain(&chain_der, &store, None)
            .expect("verification should not error");
        assert!(result.is_valid, "DER chain should verify: {:?}", result.errors);
    }

    // -----------------------------------------------------------------------
    // Verification result structure
    // -----------------------------------------------------------------------

    #[test]
    fn verification_result_chain_depth_ordering() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error");

        for (i, cert) in result.chain.iter().enumerate() {
            assert_eq!(cert.depth, i, "chain depth should be sequential");
        }
        // Leaf at depth 0
        assert!(result.chain[0].subject.contains("www.example.com"));
        // Root at last depth
        let last = &result.chain[result.chain.len() - 1];
        assert!(last.subject.contains("Test Root CA"));
    }

    #[test]
    fn verification_result_serializes_to_json() {
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = test_trust_store();
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error");
        let json = serde_json::to_string(&result).expect("should serialize to JSON");
        assert!(json.contains("is_valid"));
        assert!(json.contains("chain"));
    }

    // -----------------------------------------------------------------------
    // System trust store with real CA certificates
    // -----------------------------------------------------------------------

    #[test]
    fn system_trust_store_contains_real_cas() {
        let store = TrustStore::system().expect("system trust store should load");
        // System store should have a reasonable number of CAs
        assert!(store.len() >= 50, "system store has only {} CAs", store.len());
    }

    #[test]
    fn system_trust_store_real_ca_certs_are_parseable() {
        // Load individual real CA certs extracted from system store and verify they parse
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let cert = parse_cert(&data).unwrap_or_else(|e| {
                panic!("Real CA cert {} should parse: {}", name, e);
            });
            // Real CA certs should have CA=TRUE in basic constraints
            let is_ca = cert.extensions.iter().any(|ext| {
                matches!(&ext.value, ExtensionValue::BasicConstraints { ca: true, .. })
            });
            assert!(is_ca, "Real CA cert {} should have CA:TRUE", name);
        }
    }

    #[test]
    fn system_ca_certs_are_self_signed() {
        // Root CA certs should be self-signed (issuer == subject)
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let cert = parse_cert(&data).unwrap_or_else(|e| {
                panic!("Real CA cert {} should parse: {}", name, e);
            });
            assert_eq!(
                cert.subject.to_oneline(),
                cert.issuer.to_oneline(),
                "Root CA {} should be self-signed (subject == issuer)", name
            );
        }
    }

    #[test]
    fn system_ca_certs_verify_as_self_signed() {
        // Root CAs should verify their own signatures
        for name in ["system-ca-0.pem", "system-ca-1.pem", "system-ca-2.pem"] {
            let data = load_real_cert(name);
            let chain_der = parse_pem_chain(&data).expect("parse CA cert");
            let store = TrustStore::from_pem(&data).expect("create store from CA cert");
            let result = verify_chain(&chain_der, &store, None)
                .expect("verification should not error");
            assert!(
                result.is_valid,
                "Real CA cert {} should verify as self-signed: {:?}", name, result.errors
            );
        }
    }

    #[test]
    fn verify_chain_with_system_trust_store_and_test_chain_fails() {
        // Our test chain uses a custom root CA not in the system store
        let chain_pem = load_real_cert("test-fullchain.pem");
        let store = TrustStore::system().expect("system trust store should load");
        let result = verify_pem_chain(&chain_pem, &store, None)
            .expect("verification should not error");
        // Our test root is NOT in the system store, so this should fail
        assert!(
            !result.is_valid,
            "test chain should not verify against system store (custom root CA)"
        );
    }
}
